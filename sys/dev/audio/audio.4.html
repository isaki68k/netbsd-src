<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Wed Jan 17 22:02:35 2018 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<style type="text/css">
/*	color: #ff2800;	*/	/* 赤 */
/*	color: #0041ff;	*/	/* 青 */
/*	color: #35a16b;	*/	/* 緑 */

SPAN.n7 {
	background-color: #ffd1d1;	/* 明るいピンク */
}

P.n7 {
	background-color: #ffd1d1;	/* 明るいピンク */
}
P.n7:before {
	content: "(N7)";
	background-color: #ffd1d1;	/* 明るいピンク */
	position: absolute;
	left: 5%;
}

SPAN.n8 {
	background-color: #b4ebfa;	/* 明るい空色 */
}
P.n8 {
	background-color: #b4ebfa;	/* 明るい空色 */
}
P.n8:before {
	content: "(N8)";
	background-color: #b4ebfa;	/* 明るい空色 */
	position: absolute;
	left: 5%;
}

P.bad {
	color: #ff2800;	/* 赤 */
	font-weight: bold;
}
P.bad:before {
	content: "・";
}
P.comment {
	color: #35a16b;	/* 緑 */
	font-weight: bold;
}
P.comment:before {
	content: "・";
}
P.a2 {
	color: #0041ff;	/* 青 */
	font-weight: bold;
}
P.a2:before {
	content: "・";
}
</style>
<title></title>
</head>
<body>
ベースにしたのは NetBSD 7.1 の audio.4,v 1.72。<br>
NetBSD 8 部分は audio.4,v 1.79。<br>
<p>
凡例:<br>
<p class=n7 style="margin-left:8%;">背景ピンクの文章は NetBSD 7 から 8 になって削除されたところ。</p>
<p class=n8 style="margin-left:8%;">背景水色の文章は NetBSD 8 で追加されたところ。</p>
<p class=bad style="margin-left:8%;">赤太字は NetBSD 8 の問題についてのコメント</p>
<p class=a2 style="margin-left:8%;">青太字は AUDIO2 での仕様(案)。</p>
<p class=comment style="margin-left:8%;">緑太字はその他のコメント</p>

<hr>


<p valign="top">AUDIO(4) NetBSD Kernel Interfaces Manual
AUDIO(4)</p>

<p style="margin-top: 1em" valign="top"><b>NAME</b></p>

<p style="margin-left:8%;"><b>audio</b> &mdash;
device-independent audio driver layer</p>


<p style="margin-top: 1em" valign="top"><b>SYNOPSIS</b></p>

<p style="margin-left:8%;"><b>#include
&lt;sys/audioio.h&gt;</b></p>


<p style="margin-top: 1em" valign="top"><b>DESCRIPTION</b></p>

<p style="margin-left:8%;">The <b>audio</b> driver provides
support for various audio peripherals. It provides a uniform
programming interface layer above different underlying audio
hardware drivers. The audio layer provides full-duplex
operation if the underlying hardware configuration supports
it.</p>

<p style="margin-left:8%; margin-top: 1em">There are four
device files available for audio operation:
<i>/dev/audio</i>, <i>/dev/sound</i>, <i>/dev/audioctl</i>,
and <i>/dev/mixer</i>.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/audio</i>
and <i>/dev/sound</i> are used for recording or playback of
digital samples.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/mixer</i>
is used to manipulate volume, recording source, or other
audio mixer functions.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/audioctl</i>
accepts the same ioctl(2) operations as <i>/dev/sound</i>,
but no other operations.</p>

<p class=n7 style="margin-left:8%; margin-top: 1em">In contrast to
<i>/dev/sound</i> which has the exclusive open property
<i>/dev/audioctl</i> can be opened at any time and can be
used to manipulate the audio device while it is in use.</p>
<p class=n8 style="margin-left:8%;"><i>/dev/sound</i>
and <i>/dev/audio</i> can be opened at <i>any</i> time and
audio sources of different precision and playback parameters
i.e frequency will be mixed and played back
simultaneously.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em"><i>/dev/audioctl</i>
can be used to manipulate the audio device while it is in
use.</p>


<p style="margin-top: 1em" valign="top"><b>SAMPLING
DEVICES</b></p>

<p style="margin-left:8%;">When <i>/dev/audio</i> is
opened, it automatically directs the underlying driver to
manipulate monaural 8-bit mu-law samples. In addition, if it
is opened read-only (write-only) the device is set to
half-duplex record (play) mode with recording (playing)
unpaused and playing (recording) paused.</p>
<p class=comment style="margin-left:8%">
Read-only でオープンしたら録音モードになって再生は pause に、
Write-only でオープンしたら再生モードになって録音は pause に、と
書いてあるが、この pause は AUDIO_GETINFO で取得できる pause ではなく、
意味的なもののようだ。紛らわしい。</p>
<p style="margin-left:8%">When
<i>/dev/sound</i> is opened, it maintains the previous audio
sample mode and record/playback mode <span class=n8>most recently set on
<i>/dev/sound</i> by any open channel</span>. In all other respects
<i>/dev/audio</i> and <i>/dev/sound</i> are identical.</p>
<p class=comment style="margin-left:8%">
/dev/sound、N7 では pause は維持される仕様のようだ。
</p>

<p class=n7 style="margin-left:8%; margin-top: 1em">Only one process
may hold open a sampling device at a given time (although
file descriptors may be shared between processes once the
first open completes).</p>

<p style="background-color: #b4ebfa; margin-top: 1em" valign="top"><b>VIRTUAL
CHANNELS</b></p>

<p class=n8 style="margin-left:8%;">Any process may open a sampling
device at a given time. Any number of devices per process
and file descriptors may be shared between processes.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Virtual channels
are converted to a common format, signed linear encoding,
frequency channels and precision. These can be modified to
taste by the following sysctl(8) variables.</p>
<p class=bad style="margin-left:8%">
プローブ方法がだめだめすぎる。
</p>
<p class=bad style="margin-left:8%">
起動後に sysctl で変更できるが、HW で有効な選択肢は提示されない。</p>
<p class=bad style="margin-left:8%">
sysctl で HW で有効でない値をセットしてもエラーにならない。</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.precision</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.frequency</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.channels</p>

<p class=bad style="margin-left:12%; margin-top:1em">
そもそもこれらを sysctl で設定させるのがおかしい。</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.multiuser</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Where
<i>driverN</i> corresponds to the underlying audio device
driver and device number. e.g In the case of an hdafg
supported device the variables would be: hw.hdafg0.channels,
hw.hdafg0.precision, hw.hdafg0.frequency.</p>
<p class=bad style="margin-left:8%">
hw.hdafg0.* のようなMD名ではなく hw.audio0.* を使うべき。
実際 hdafg(4) は hw.hdafg に独自の ioctl を持っている。
</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">For best
results, values close to the underlying hardware should be
chosen. These variables may only be changed when the
sampling device is not in use.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">An additional
sysctl(8) variable determines if multiple users are allowed
to access the sampling device, hw.driverN.multiuser.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">By default it is
set to false. This means that the sampling device may be
only used by <i>one</i> user at a time. Other users (except
root) attempting to open the sampling device will be
denied.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">If set to true,
all users may access the sampling device at any time.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Each virtual
channel has a corresponding mixer:</p>

<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">vchan.dacN Output
volume</p>

<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">vchan.micN
Recording volume</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Where N is the
virtual channel number. e.g vchan.dac0 controlling playback
volume and vchan.mic0 controlling recording volume for the
first virtual channel.</p>

<p style="margin-left:8%; margin-top: 1em">On a half-duplex
device, writes while recording is in progress will be
immediately discarded. Similarly, reads while playback is in
progress will be filled with silence but delayed to return
at the current sampling rate. If both playback and recording
are requested on a half-duplex device, playback mode takes
precedence and recordings will get silence.</p>

<p style="margin-left:8%; margin-top: 1em">On a full-duplex
device, reads and writes may operate concurrently without
interference. If a full-duplex capable audio device is
opened for both reading and writing it will start in
half-duplex play mode; full-duplex mode has to be set
explicitly.</p>
<p class=comment style="margin-left:8%">
「Full-duplex 対応オーディオデバイスは reading または writing の
どちらでオープンされても、half-duplex 再生モードになる。
full-duplex モードには明示的にセットする必要がある」
要動作確認。
</p>

<p style="margin-left:8%; margin-top: 1em">On either type
of device, if the playback mode is paused then silence is
played instead of the provided samples, and if recording is
paused then the process blocks in read(2) until recording is
unpaused.</p>

<p style="margin-left:8%; margin-top: 1em">If a writing
process does not call write(2) frequently enough to provide
samples at the pace the hardware consumes them silence is
inserted. If the AUMODE_PLAY_ALL mode is not set the writing
process must provide enough data via subsequent write calls
to &lsquo;&lsquo;catch up&rsquo;&rsquo; in time to the
current audio block before any more process-provided samples
will be played. If a reading process does not call read(2)
frequently enough, it will simply miss samples.</p>

<p style="margin-left:8%; margin-top: 1em">The audio device
is normally accessed with read(2) or write(2) calls, but it
can also be mapped into user memory with mmap(2) <span class=n7>(when
supported by the device)</span>. Once the device has been mapped it
can no longer be accessed by read or write; all access is by
reading and writing to the mapped memory. The device appears
as a block of memory of size <i>buffersize</i> (as available
via AUDIO_GETINFO or AUDIO_GETBUFINFO). The device driver
will continuously move data from this buffer from/to the
audio hardware, wrapping around at the end of the buffer. To
find out where the hardware is currently accessing data in
the buffer the AUDIO_GETIOFFS and AUDIO_GETOOFFS calls can
be used. The playing and recording buffers are distinct and
must be mapped separately if both are to be used. Only
encodings that are not emulated (i.e. where
AUDIO_ENCODINGFLAG_EMULATED is not set) work properly for a
mapped device.</p>
<p class=comment style="margin-left:8%">mmap(2) 全般は後回し。
現行仕様に問題が多い。</p>

<p style="margin-left:8%; margin-top: 1em">The audio
device, like most devices, can be used in <i>select</i>, can
be set in non-blocking mode and can be set (with a FIOASYNC
ioctl) to send a SIGIO when I/O is possible. The mixer
device can be set to generate a SIGIO whenever a mixer value
is changed.</p>
<p class=bad style="margin-left:8%">
FIOASYNC が VC 分離されていない。
プロセスAが FIOASYNC を on にしても、
別のプロセスBが(ユーザにも特権にも関係なく) FIOASYNC を off にできる。
また FIOASYNC がリセットされるのは再生+録音の最終クローズ時であるため、
プロセスAがデバイスをオープンしたまま
別のプロセスBが FIOASYNC をセットしてクローズしても
まだ FIOASYNC がリセットされず、次にオープンしても FIOASYNC をセットできない。
</p>

<p style="margin-left:8%; margin-top: 1em">The following
ioctl(2) commands are supported on the sample devices:</p>

<p class=n8 style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETCHAN
(int)</p>

<p class=n8 style="margin-left:20%;">This command will return the
audio channel in use.</p>

<p class=n8 style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETCHAN
(int)</p>

<p class=n8 style="margin-left:20%;">This command will select the
audio channel for subsequent ioctl calls.</p>
<p class=bad style="margin-left:20%">
(ユーザにも特権にも関係なく) 他のVCを指定することができて
(その後の ioctl でその VC の状態を変更できて) しまうのでセキュリティ上アウト
→ <a href="http://gnats.netbsd.org/52627">kern/52627</a></p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_FLUSH</p>

<p style="margin-left:20%;">This command stops all playback
and recording, clears all queued buffers, resets error
counters, and restarts recording and playback as appropriate
for the current sampling mode.</p>
<p class=comment style="margin-left:20%">
エラーカウンタをリセットするとあるが、具体的にどれか確認すること。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_RERROR
(int)</p>

<p style="margin-left:20%;">This command fetches the count
of dropped input samples into its integer argument. There is
no information regarding when in the sample stream they were
dropped.</p>
<p class=a2 style="margin-left:20%">サンプル数と書いてあるが、
バイト数を返すことにしたい。</p>
<p class=comment style="margin-left:20%">たしかそんな PR が出てた気がする。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_WSEEK
(u_long)</p>

<p style="margin-left:20%;">This command fetches the count
of samples that are queued ahead of the first sample in the
most recent sample block written into its integer
argument.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_DRAIN</p>

<p style="margin-left:20%;">This command suspends the
calling process until all queued playback samples have been
played by the hardware.</p>
<p class=bad style="margin-left:20%">
x68k くらいの遅マシンでは drain の挙動がなんか変。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETDEV
(audio_device_t)</p>

<p style="margin-left:20%;">This command fetches the
current hardware device information into the audio_device_t
argument.</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_device {
	char name[MAX_AUDIO_DEV_LEN];
	char version[MAX_AUDIO_DEV_LEN];
	char config[MAX_AUDIO_DEV_LEN];
} audio_device_t;</pre>
</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETFD
(int)</p>

<p style="margin-left:20%;">The command returns the current
setting of the full duplex mode.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETENC
(audio_encoding_t)</p>

<p style="margin-left:20%;">This command is used
iteratively to fetch sample encoding names and format_ids
into the input/output audio_encoding_t argument.</p>
<p class=bad style="margin-left:20%">
N7 までは MD がサポートしているエンコーディングと
ユーザランドから入出力できるエンコーディングとが一致していたからよかったが、
N8 ではそれが一致しなくなったため、AUDIO_GETENC が何を(どちらを)
返すべきものなのかを再定義するなり何なりの対応をしなければいけないが、
そうはなっていない。
というか、今はそのどちらでもないよくわからん集合が返ってくる。
</p>
<p class=a2 style="margin-left:20%">
AUDIO_GETENC は MD がサポートしているエンコーディングを返す。</p>
<p class=a2 style="margin-left:20%">
ユーザランドから入出力できるエンコーディングは別の ioctl を新設かなあ。
</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_encoding {
	int index;			/* input: nth encoding */
	char name[MAX_AUDIO_DEV_LEN];	/* name of encoding */
	int encoding;			/* value for encoding parameter */
	int precision;			/* value for precision parameter */
	int flags;
#define AUDIO_ENCODINGFLAG_EMULATED 1	/* software emulation mode */
} audio_encoding_t;</pre>
</p>

<p style="margin-left:20%; margin-top: 1em">To query all
the supported encodings, start with an index field of 0 and
continue with successive encodings (1, 2, ...) until the
command returns an error.</p>


<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETFD
(int)</p>

<p style="margin-left:20%;">This command sets the device
into full-duplex operation if its integer argument has a
non-zero value, or into half-duplex operation if it contains
a zero value. If the device does not support full-duplex
operation, attempting to set full-duplex mode returns an
error.</p>
<p class=bad style="margin-left:20%;">
自VC の Full/Half 状態だけでなく
setfd インタフェースで HWの状態を直接変更している。
setfd インタフェースでデバッグ printf 以上のことをしている
MD ドライバは1つも存在しないので影響は顕在化しないが
本来はおかしいはず。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETPROPS
(int)</p>

<p style="margin-left:20%;">This command gets a bit set of
hardware properties. If the hardware has a certain property
the corresponding bit is set, otherwise it is not. The
properties can have the following values:</p>


<p style="margin-left:22%;margin-top: 1em" valign="top">AUDIO_PROP_FULLDUPLEX</p>

<p style="margin-left:27%">the device
admits full duplex operation.</p>

<p style="margin-left:22%">AUDIO_PROP_MMAP</p>

<p style="margin-left:27%">the device can
be used with mmap(2).</p>

<p style="margin-left:22%">AUDIO_PROP_INDEPENDENT</p>

<p style="margin-left:27%">the device can
set the playing and recording encoding parameters
independently.</p>

<p style="margin-left:22%">AUDIO_PROP_PLAYBACK</p>

<p style="margin-left:27%">the device is
capable of audio playback.</p>

<p style="margin-left:22%">AUDIO_PROP_CAPTURE</p>

<p style="margin-left:27%">the device is
capable of audio capture.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETIOFFS
(audio_offset_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETOOFFS
(audio_offset_t)</p>

<p style="margin-left:20%;">This command fetches the
current offset in the input(output) buffer where the audio
hardware&rsquo;s DMA engine will be putting(getting) data.
It mostly useful when the device buffer is available in user
space via the mmap(2) call. The information is returned in
the audio_offset structure.</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_offset {
	u_int	samples;	/* Total number of bytes transferred */
	u_int	deltablks;	/* Blocks transferred since last checked */
	u_int	offset;		/* Physical transfer offset in buffer */
}</pre></p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETINFO
(audio_info_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETBUFINFO
(audio_info_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETINFO
(audio_info_t)</p>

<p style="margin-left:20%;">Get or set audio information as
encoded in the audio_info structure.</p>
<p class=bad style="margin-left:20%">
設定項目が多いので設定中にエラーが起きると本来は全部ロールバックしないと
いけないような気がするのと初期の頃のソースは一応その辺も
意識してあったように見えるが、
(N7 以前からだが)
今となってはもう複雑すぎてロールバックは一切お察しのような気がする。</p>
<p class=a2 style="margin-left:20%">
一応エラーの際には完全にロールバックを目指すようには作っているが、
今まで10年近くロールバックしない動作だったので逆に問題になるかも知れない。
</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_info {
	struct audio_prinfo play;	/* info for play (output) side */
	struct audio_prinfo record;	/* info for record (input) side */
	u_int	monitor_gain;		/* input to output mix */

	/* BSD extensions */
	u_int	blocksize;		/* H/W read/write block size */
	u_int	hiwat;			/* output high water mark */
	u_int	lowat;			/* output low water mark */
	u_int	_ispare1;
	u_int	mode;			/* current device mode */
#define AUMODE_PLAY	0x01
#define AUMODE_RECORD	0x02
#define AUMODE_PLAY_ALL	0x04		/* do not do real-time correction */
} audio_info_t;</pre>
</p>

<p style="margin-left:20%; margin-top: 1em">When setting
the current state with AUDIO_SETINFO, the audio_info
structure should first be initialized with AUDIO_INITINFO
(&amp;info ) and then the particular values
to be changed should be set. This allows the audio driver to
only set those things that you wish to change and eliminates
the need to query the device with AUDIO_GETINFO or
AUDIO_GETBUFINFO first.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>mode</i>
field should be set to AUMODE_PLAY, AUMODE_RECORD,
AUMODE_PLAY_ALL, or a bitwise OR combination of the three.
Only full-duplex audio devices support simultaneous record
and playback.</p>

<p style="margin-left:20%; margin-top: 1em"><i>hiwat</i>
and <i>lowat</i> are used to control write behavior. Writes
to the audio devices will queue up blocks until the
high-water mark is reached, at which point any more write
calls will block until the queue is drained to the low-water
mark. <i>hiwat</i> and <i>lowat</i> set those high- and
low-water marks (in audio blocks). The default for
<i>hiwat</i> is the maximum value and for <i>lowat</i> 75 %
of <i>hiwat</i>.</p>
<p class=a2 style="margin-left:20%">バッファの構造が変わったため
lowat を 50% かそれ以下にしたい。
元々ユーザランドから見えるバッファがハードウェアバッファだったため、
ハードウェアバッファを途切れさせないために lowat を高めにする必要があったが、
AUDIO2 の構造ではユーザランドバッファとハードウェアバッファの間に
ものすごくいろいろあって、同じ理屈にはならない。
むしろ lowat を低くするほうが uiomove の回数を減らせて有利かもしれないくらい
まである。
</p>


<p style="margin-left:20%; margin-top: 1em"><i>blocksize</i>
sets the current audio blocksize. The generic audio driver
layer and the hardware driver have the opportunity to adjust
this block size to get it within implementation-required
limits. Upon return from an AUDIO_SETINFO call, the actual
blocksize set is returned in this field. Normally the
<i>blocksize</i> is calculated to correspond to 50ms of
sound and it is recalculated when the encoding parameter
changes, but if the <i>blocksize</i> is set explicitly this
value becomes sticky, i.e., it remains even when the
encoding is changed. The stickiness can be cleared by
reopening the device or setting the <i>blocksize</i> to
0.</p>
<p class=a2 style="margin-left:20%">
AUDIO2 では hardware driver がブロックサイズを変更する機会は今の所たぶん持たない。
</p>
<p class=a2 style="margin-left:20%">
従って AUDIO_SETINFO も書き戻しを行わない予定。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではブロックサイズはデフォルトで 40msec 分のサイズになるようにしてある。
ただし HW の制約により 40msec で問題がある場合は
問題のないところまで自動で拡張する。
これがおきるのは今の所 x68k の vs(4) だけ。
将来的にはカーネルコンフィグの
AUDIO_BLK_MS でコンパイル時に変更できるようにしたい。
</p>
<p class=a2 style="margin-left:20%">
エンコーディングを変更するとブロックサイズは常に追従する。
スティッキーモードは実装しない予定。
</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">struct audio_prinfo {
	u_int	sample_rate;	/* sample rate in samples/s */
	u_int	channels;	/* number of channels, usually 1 or 2 */
	u_int	precision;	/* number of bits/sample */
	u_int	encoding;	/* data encoding (AUDIO_ENCODING_* below) */
	u_int	gain;		/* volume level */
	u_int	port;		/* selected I/O port */
	u_long	seek;		/* BSD extension */
	u_int	avail_ports;	/* available I/O ports */
	u_int	buffer_size;	/* total size audio buffer */
	u_int	_ispare[1];	/* Current state of device: */
	u_int	samples;	/* number of samples */
	u_int	eof;		/* End Of File (zero-size writes) counter */
	u_char	pause;		/* non-zero if paused, zero to resume */
	u_char	error;		/* non-zero if underflow/overflow occurred */
	u_char	waiting;	/* non-zero if another process hangs in open */
	u_char	balance;	/* stereo channel balance */
	u_char	cspare[2];
	u_char	open;		/* non-zero if currently open */
	u_char	active;		/* non-zero if I/O is currently active */
};</pre>
</p>

<p class=bad class=ul style="margin-left:20%">
sample_rate = 0 を設定すると、システムコールが無限ループになって(?)帰ってこない。
N7 以前でも起きる。
N7 以前ならオーディオデバイスを開けるのは高々1人なので
それ以上影響は広がらないが、N8 だといくらでもオープンできるので以下略。
ちなみに shutdown も出来なくなる。
</ul>
</p>
<p class=bad style="margin-left:20%">
eof カウンタが VC 分離できていない。
あるディスクリプタで eof カウンタが上がると別ディスクリプタでも同じ値が読める。
全 VC が閉じられるとリセットされる。
この変数になんの意味があるかはともかく、おそらく元の仕様の意図はそうではない。
</p>

<p style="margin-left:20%; margin-top: 1em">Note: many
hardware audio drivers require identical playback and
recording sample rates, sample encodings, and channel
counts. The playing information is always set last and will
prevail on such hardware. If the hardware can handle
different settings the AUDIO_PROP_INDEPENDENT property is
set.</p>

<p style="margin-left:20%; margin-top: 1em">The encoding
parameter can have the following values:</p>


<p style="margin-left:22%; margin-top: 1em" valign="top">AUDIO_ENCODING_ULAW</p>

<p style="margin-left:27%">mu-law
encoding, 8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_ALAW</p>

<p style="margin-left:27%">A-law encoding,
8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with the platform byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR</p>

<p style="margin-left:27%">unsigned linear
encoding with the platform byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ADPCM</p>

<p style="margin-left:27%">ADPCM encoding,
8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR_LE</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with little endian byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR_BE</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with big endian byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR_LE</p>

<p style="margin-left:27%">unsigned linear
encoding with little endian byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR_BE</p>

<p style="margin-left:27%">unsigned linear
encoding with big endian byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_AC3</p>

<p style="margin-left:27%">Dolby Digital
AC3</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>gain</i>, <i>port</i> and <i>balance</i> settings provide
simple shortcuts to the richer mixer interface described
below and are not obtained by AUDIO_GETBUFINFO. The gain
should be in the range [AUDIO_MIN_GAIN, AUDIO_MAX_GAIN] and
the balance in the range [AUDIO_LEFT_BALANCE,
AUDIO_RIGHT_BALANCE] with the normal setting at
AUDIO_MID_BALANCE.</p>
<p class=bad style="margin-left:20%">
balance と gain は元々セットで HW ミキサーを指していたが、
このうち gain の設定だけ VC のマスターボリュームの変更に書き換えられ、
gain の取得と balance の設定・取得は HW ミキサーのままなので、いろいろ整合していない。
PR が出ている → <a href="https://gnats.netbsd.org/52781">kern/52781</a>
</p>

<p style="margin-left:20%; margin-top: 1em">The input port
should be a combination of:</p>


<p style="margin-left:22%; margin-top: 1em">AUDIO_MICROPHONE</p>

<p style="margin-left:27%">to select
microphone input.</p>

<p style="margin-left:22%">AUDIO_LINE_IN</p>

<p style="margin-left:27%">to select line
input.</p>

<p style="margin-left:22%">AUDIO_CD</p>

<p style="margin-left:27%">to select CD
input.</p>

<p style="margin-left:20%; margin-top: 1em">The output port
should be a combination of:</p>

<p style="margin-left:22%; margin-top: 1em">AUDIO_SPEAKER</p>

<p style="margin-left:27%">to select
speaker output.</p>

<p style="margin-left:22%">AUDIO_HEADPHONE</p>

<p style="margin-left:27%">to select
headphone output.</p>

<p style="margin-left:22%">AUDIO_LINE_OUT</p>

<p style="margin-left:27%">to select line
output.</p>

<p style="margin-left:20%; margin-top: 1em">The available
ports can be found in <i>avail_ports</i> (AUDIO_GETBUFINFO
only).</p>


<p style="margin-left:20%; margin-top: 1em"><i>buffer_size</i>
is the total size of the audio buffer. The buffer size
divided by the <i>blocksize</i> gives the maximum value for
<i>hiwat</i>. Currently the <i>buffer_size</i> can only be
read and not set.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>seek</i>
and <i>samples</i> fields are only used by AUDIO_GETINFO and
AUDIO_GETBUFINFO. <i>seek</i> represents the count of
samples pending; <i>samples</i> represents the total number
of bytes recorded or played, less those that were dropped
due to inadequate consumption/production rates.</p>
<p class=a2 style="margin-left:20%">
seek はサンプル数とあるがバイト数にしたい。
</p>

<p style="margin-left:20%; margin-top: 1em"><i>pause</i>
returns the current pause/unpause state for recording or
playback. For AUDIO_SETINFO, if the pause value is specified
it will either pause or unpause the particular
direction.</p>

<p style="margin-top: 1em" valign="top"><b>MIXER
DEVICE</b></p>

<p class=comment style="margin-left:8%">ミキサーデバイスについてはほぼ未考察。
</p>

<p style="margin-left:8%;">The mixer device,
<i>/dev/mixer</i>, may be manipulated with ioctl(2) but does
not support read(2) or write(2). It supports the following
ioctl(2) commands:</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_GETDEV
(audio_device_t)</p>

<p style="margin-left:20%;">This command is the same as
described above for the sampling devices.</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_READ
(mixer_ctrl_t)</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_WRITE
(mixer_ctrl_t)</p>

<p style="margin-left:20%;">These commands read the current
mixer state or set new mixer state for the specified device
<i>dev</i>. <i>type</i> identifies which type of value is
supplied in the <i>mixer_ctrl_t</i> argument.</p>

<p style="margin-left:20%; margin-top: 1em">#define
AUDIO_MIXER_CLASS 0 <br>
#define AUDIO_MIXER_ENUM 1 <br>
#define AUDIO_MIXER_SET 2 <br>
#define AUDIO_MIXER_VALUE 3 <br>
typedef struct mixer_ctrl {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int dev;</p></td>
<td width="12%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">/* input: nth device */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int type;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">union {</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">int ord;</p></td>
<td width="12%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">/* enum */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">int mask;</p></td>
<td width="12%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">/* set */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">mixer_level_t value;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%">


<p valign="top">/* value */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">} un;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
</table>

<p style="margin-left:20%;">} mixer_ctrl_t;</p>

<p style="margin-left:20%; margin-top: 1em">#define
AUDIO_MIN_GAIN 0 <br>
#define AUDIO_MAX_GAIN 255 <br>
typedef struct mixer_level { <br>
int num_channels; <br>
u_char level[8]; /* [num_channels] */ <br>
} mixer_level_t; <br>
#define AUDIO_MIXER_LEVEL_MONO 0 <br>
#define AUDIO_MIXER_LEVEL_LEFT 0 <br>
#define AUDIO_MIXER_LEVEL_RIGHT 1</p>

<p style="margin-left:20%; margin-top: 1em">For a mixer
value, the <i>value</i> field specifies both the number of
channels and the values for each channel. If the channel
count does not match the current channel count, the attempt
to change the setting may fail (depending on the hardware
device driver implementation). For an enumeration value, the
<i>ord</i> field should be set to one of the possible values
as returned by a prior AUDIO_MIXER_DEVINFO command. The type
AUDIO_MIXER_CLASS is only used for classifying particular
mixer device types and is not used for AUDIO_MIXER_READ or
AUDIO_MIXER_WRITE.</p>


<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_DEVINFO
(mixer_devinfo_t)</p>

<p style="margin-left:20%;">This command is used
iteratively to fetch audio mixer device information into the
input/output mixer_devinfo_t argument. To query all the
supported devices, start with an index field of 0 and
continue with successive devices (1, 2, ...) until the
command returns an error.</p>

<p style="margin-left:20%; margin-top: 1em">typedef struct
mixer_devinfo {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">int index;</p></td>
<td width="12%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* input: nth mixer device */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">audio_mixer_name_t label;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">int type;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">int mixer_class;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">int next, prev;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">


<p valign="top">#define AUDIO_MIXER_LAST</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">-1</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">union {</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">struct audio_mixer_enum {</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int num_mem;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">struct {</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">audio_mixer_name_t label;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">int ord;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">} member[32];</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">} e;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">struct audio_mixer_set {</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int num_mem;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">struct {</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">audio_mixer_name_t label;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">int mask;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">} member[32];</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">} s;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">struct audio_mixer_value {</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">audio_mixer_name_t units;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int num_channels;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int delta;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">} v;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">} un;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
</table>

<p style="margin-left:20%;">} mixer_devinfo_t;</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>label</i> field identifies the name of this particular
mixer control. The <i>index</i> field may be used as the
<i>dev</i> field in AUDIO_MIXER_READ and AUDIO_MIXER_WRITE
commands. The <i>type</i> field identifies the type of this
mixer control. Enumeration types are typically used for
on/off style controls (e.g. a mute control) or for
input/output device selection (e.g. select recording input
source from CD, line in, or microphone). Set types are
similar to enumeration types but any combination of the mask
bits can be used.</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>mixer_class</i> field identifies what class of control
this is. The (arbitrary) value set by the hardware driver
may be determined by examining the <i>mixer_class</i> field
of the class itself, a mixer of type AUDIO_MIXER_CLASS. For
example, a mixer controlling the input gain on the line in
circuit would have a <i>mixer_class</i> that matches an
input class device with the name
&lsquo;&lsquo;inputs&rsquo;&rsquo; (AudioCinputs), and would
have a <i>label</i> of &lsquo;&lsquo;line&rsquo;&rsquo;
(AudioNline). Mixer controls which control audio circuitry
for a particular audio source (e.g. line-in, CD in, DAC
output) are collected under the input class, while those
which control all audio sources (e.g. master volume,
equalization controls) are under the output class. Hardware
devices capable of recording typically also have a record
class, for controls that only affect recording, and also a
monitor class.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>next</i>
and <i>prev</i> may be used by the hardware device driver to
provide hints for the next and previous devices in a related
set (for example, the line in level control would have the
line in mute as its &lsquo;&lsquo;next&rsquo;&rsquo; value).
If there is no relevant next or previous value,
AUDIO_MIXER_LAST is specified.</p>

<p style="margin-left:20%; margin-top: 1em">For
AUDIO_MIXER_ENUM mixer control types, the enumeration values
and their corresponding names are filled in. For example, a
mute control would return appropriate values paired with
AudioNon and AudioNoff. For AUDIO_MIXER_VALUE and
AUDIO_MIXER_SET mixer control types, the channel count is
returned; the units name specifies what the level controls
(typical values are AudioNvolume, AudioNtreble,
AudioNbass).</p>

<p style="margin-left:8%; margin-top: 1em">By convention,
all the mixer devices can be distinguished from other mixer
controls because they use a name from one of the AudioC*
string values.</p>

<p style="margin-top: 1em" valign="top"><b>FILES</b> <br>
<p style="margin-left:8%">
/dev/audio <br>
<p style="margin-left:8%">
/dev/audioctl <br>
<p style="margin-left:8%">
/dev/sound <br>
<p style="margin-left:8%">
/dev/mixer <br>

<p style="margin-top: 1em" valign="top"><b>SEE ALSO</b> <br>

<p style="margin-left:8%;">audioctl(1), mixerctl(1),
ioctl(2), ossaudio(3), midi(4), radio(4)<span class=n8>, sysctl(8)</span></p>

<p style="margin-left:8%; margin-top: 1em"><b>ISA bus</b>
<br>
aria(4), ess(4), gus(4), guspnp(4), pas(4), sb(4), wss(4),
ym(4)</p>

<p style="margin-left:8%; margin-top: 1em"><b>PCI bus</b>
<br>
auacer(4), auich(4), auixp(4), autri(4), auvia(4),
azalia(4), clcs(4), clct(4), cmpci(4), eap(4), emuxki(4),
esa(4), esm(4), eso(4), fms(4), neo(4), sv(4), yds(4)</p>


<p style="margin-left:8%; margin-top: 1em"><b>TURBOchannel</b>
<br>
bba(4)</p>

<p style="margin-left:8%; margin-top: 1em"><b>USB</b> <br>
uaudio(4)</p>

<p style="margin-top: 1em" valign="top"><span class=n7><b>BUGS</b></span></p>

<p class=n7 style="margin-left:8%;">If the device is used in mmap(2)
it is currently always mapped for writing (playing) due to
VM system weirdness.</p>
<p class=bad style="margin-left:8%">これ解決したんだっけ?</p>

<p style="margin-top: 1em" valign="top"><span class=n8><b>HISTORY</b></span></p>
<p class=n8 style="margin-left:8%;">Support for virtual channels and
mixing first appeared in NetBSD&nbsp;8.0.</p>

<p style="margin-left:8%; margin-top: 1em">NetBSD&nbsp;7.1.1
September&nbsp;5, 2011 NetBSD&nbsp;7.1.1</p>
<hr>
</body>
</html>
