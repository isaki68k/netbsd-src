<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Wed Jan 17 22:02:35 2018 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<style type="text/css">
/*	color: #ff2800;	*/	/* 赤 */
/*	color: #0041ff;	*/	/* 青 */
/*	color: #35a16b;	*/	/* 緑 */

SPAN.n7 {
	background-color: #ffd1d1;	/* 明るいピンク */
}

P.n7 {
	background-color: #ffd1d1;	/* 明るいピンク */
}
P.n7:before {
	content: "(N7)";
	background-color: #ffd1d1;	/* 明るいピンク */
	position: absolute;
	left: 5%;
}

SPAN.n8 {
	background-color: #b4ebfa;	/* 明るい空色 */
}
P.n8 {
	background-color: #b4ebfa;	/* 明るい空色 */
}
P.n8:before {
	content: "(N8)";
	background-color: #b4ebfa;	/* 明るい空色 */
	position: absolute;
	left: 5%;
}

P.n9 {
	background-color: #87e7b0;	/* 明るい緑 */
}
P.n9:before {
	content: "(A2)";
	background-color: #87e7b0;	/* 明るい緑 */
	position: absolute;
	left: 5%;
}

P.bad {
	color: #ff2800;	/* 赤 */
	font-weight: bold;
}
P.comment {
	color: black;
	font-weight: bold;
}
</style>
<title></title>
</head>
<body>
ベースにしたのは NetBSD 7.1 の audio.4,v 1.72。<br>
NetBSD 8 部分は audio.4,v 1.79。<br>
<p>
凡例:<br>
<p class=n7 style="margin-left:8%;">背景ピンクの文章は NetBSD 7 から 8 になって削除されたところ。</p>
<p class=n8 style="margin-left:8%;">背景水色の文章は NetBSD 8 で追加されたところ。</p>
<p class=n9 style="margin-left:8%;">背景緑の文章は AUDIO2 で改訂したいところ。</p>
<p class=comment style="margin-left:8%;">黒太字は NetBSD 7 からある問題についてのコメント</p>
<p class=bad style="margin-left:8%;">赤太字は NetBSD 8 の問題についてのコメント</p>

<hr>


<p valign="top">AUDIO(4) NetBSD Kernel Interfaces Manual
AUDIO(4)</p>

<p style="margin-top: 1em" valign="top"><b>NAME</b></p>

<p style="margin-left:8%;"><b>audio</b> &mdash;
device-independent audio driver layer</p>


<p style="margin-top: 1em" valign="top"><b>SYNOPSIS</b></p>

<p style="margin-left:8%;"><b>#include
&lt;sys/audioio.h&gt;</b></p>


<p style="margin-top: 1em" valign="top"><b>DESCRIPTION</b></p>

<p style="margin-left:8%;">The <b>audio</b> driver provides
support for various audio peripherals. It provides a uniform
programming interface layer above different underlying audio
hardware drivers. The audio layer provides full-duplex
operation if the underlying hardware configuration supports
it.</p>

<p style="margin-left:8%; margin-top: 1em">There are four
device files available for audio operation:
<i>/dev/audio</i>, <i>/dev/sound</i>, <i>/dev/audioctl</i>,
and <i>/dev/mixer</i>.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/audio</i>
and <i>/dev/sound</i> are used for recording or playback of
digital samples.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/mixer</i>
is used to manipulate volume, recording source, or other
audio mixer functions.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/audioctl</i>
accepts the same ioctl(2) operations as <i>/dev/sound</i>,
but no other operations.</p>

<p class=n7 style="margin-left:8%; margin-top: 1em">In contrast to
<i>/dev/sound</i> which has the exclusive open property
<i>/dev/audioctl</i> can be opened at any time and can be
used to manipulate the audio device while it is in use.</p>
<p class=n8 style="margin-left:8%;"><i>/dev/sound</i>
and <i>/dev/audio</i> can be opened at <i>any</i> time and
audio sources of different precision and playback parameters
i.e frequency will be mixed and played back
simultaneously.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em"><i>/dev/audioctl</i>
can be used to manipulate the audio device while it is in
use.</p>


<p style="margin-top: 1em" valign="top"><b>SAMPLING
DEVICES</b></p>

<p style="margin-left:8%;">When <i>/dev/audio</i> is
opened, it automatically directs the underlying driver to
manipulate monaural 8-bit mu-law samples. In addition, if it
is opened read-only (write-only) the device is set to
half-duplex record (play) mode with recording (playing)
unpaused and playing (recording) paused. When
<i>/dev/sound</i> is opened, it maintains the previous audio
sample mode and record/playback mode <span class=n8>most recently set on
<i>/dev/sound</i> by any open channel</span>. In all other respects
<i>/dev/audio</i> and <i>/dev/sound</i> are identical.</p>

<p class=n7 style="margin-left:8%; margin-top: 1em">Only one process
may hold open a sampling device at a given time (although
file descriptors may be shared between processes once the
first open completes).</p>

<p style="background-color: #b4ebfa; margin-top: 1em" valign="top"><b>VIRTUAL
CHANNELS</b></p>

<p class=n8 style="margin-left:8%;">Any process may open a sampling
device at a given time. Any number of devices per process
and file descriptors may be shared between processes.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Virtual channels
are converted to a common format, signed linear encoding,
frequency channels and precision. These can be modified to
taste by the following sysctl(8) variables.</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.precision</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.frequency</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.channels</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.multiuser</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Where
<i>driverN</i> corresponds to the underlying audio device
driver and device number. e.g In the case of an hdafg
supported device the variables would be: hw.hdafg0.channels,
hw.hdafg0.precision, hw.hdafg0.frequency.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">For best
results, values close to the underlying hardware should be
chosen. These variables may only be changed when the
sampling device is not in use.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">An additional
sysctl(8) variable determines if multiple users are allowed
to access the sampling device, hw.driverN.multiuser.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">By default it is
set to false. This means that the sampling device may be
only used by <i>one</i> user at a time. Other users (except
root) attempting to open the sampling device will be
denied.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">If set to true,
all users may access the sampling device at any time.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Each virtual
channel has a corresponding mixer:</p>

<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">vchan.dacN Output
volume</p>

<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">vchan.micN
Recording volume</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Where N is the
virtual channel number. e.g vchan.dac0 controlling playback
volume and vchan.mic0 controlling recording volume for the
first virtual channel.</p>

<p style="margin-left:8%; margin-top: 1em">On a half-duplex
device, writes while recording is in progress will be
immediately discarded. Similarly, reads while playback is in
progress will be filled with silence but delayed to return
at the current sampling rate. If both playback and recording
are requested on a half-duplex device, playback mode takes
precedence and recordings will get silence.</p>

<p style="margin-left:8%; margin-top: 1em">On a full-duplex
device, reads and writes may operate concurrently without
interference. If a full-duplex capable audio device is
opened for both reading and writing it will start in
half-duplex play mode; full-duplex mode has to be set
explicitly.</p>

<p style="margin-left:8%; margin-top: 1em">On either type
of device, if the playback mode is paused then silence is
played instead of the provided samples, and if recording is
paused then the process blocks in read(2) until recording is
unpaused.</p>

<p style="margin-left:8%; margin-top: 1em">If a writing
process does not call write(2) frequently enough to provide
samples at the pace the hardware consumes them silence is
inserted. If the AUMODE_PLAY_ALL mode is not set the writing
process must provide enough data via subsequent write calls
to &lsquo;&lsquo;catch up&rsquo;&rsquo; in time to the
current audio block before any more process-provided samples
will be played. If a reading process does not call read(2)
frequently enough, it will simply miss samples.</p>

<p style="margin-left:8%; margin-top: 1em">The audio device
is normally accessed with read(2) or write(2) calls, but it
can also be mapped into user memory with mmap(2) <span class=n7>(when
supported by the device)</span>. Once the device has been mapped it
can no longer be accessed by read or write; all access is by
reading and writing to the mapped memory. The device appears
as a block of memory of size <i>buffersize</i> (as available
via AUDIO_GETINFO or AUDIO_GETBUFINFO). The device driver
will continuously move data from this buffer from/to the
audio hardware, wrapping around at the end of the buffer. To
find out where the hardware is currently accessing data in
the buffer the AUDIO_GETIOFFS and AUDIO_GETOOFFS calls can
be used. The playing and recording buffers are distinct and
must be mapped separately if both are to be used. Only
encodings that are not emulated (i.e. where
AUDIO_ENCODINGFLAG_EMULATED is not set) work properly for a
mapped device.</p>

<p style="margin-left:8%; margin-top: 1em">The audio
device, like most devices, can be used in <i>select</i>, can
be set in non-blocking mode and can be set (with a FIOASYNC
ioctl) to send a SIGIO when I/O is possible. The mixer
device can be set to generate a SIGIO whenever a mixer value
is changed.</p>

<p style="margin-left:8%; margin-top: 1em">The following
ioctl(2) commands are supported on the sample devices:</p>

<p class=n8 style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETCHAN
(int)</p>

<p class=n8 style="margin-left:20%;">This command will return the
audio channel in use.</p>

<p class=n8 style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETCHAN
(int)</p>

<p class=n8 style="margin-left:20%;">This command will select the
audio channel for subsequent ioctl calls.</p>
<p class=bad style="margin-left:20%">他のユーザのVCを認証なく指定できて
(その後の ioctl で VC 状態を変更できて) しまうのでセキュリティ上アウト
→ <a href="http://gnats.netbsd.org/52627">kern/52627</a></p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_FLUSH</p>

<p style="margin-left:20%;">This command stops all playback
and recording, clears all queued buffers, resets error
counters, and restarts recording and playback as appropriate
for the current sampling mode.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_RERROR
(int)</p>

<p style="margin-left:20%;">This command fetches the count
of dropped input samples into its integer argument. There is
no information regarding when in the sample stream they were
dropped.</p>
<p class=comment style="margin-left:20%">サンプル数と書いてあるが、
バイト数を返すことにしたい。たしかそんな PR が出てた気がする。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_WSEEK
(u_long)</p>

<p style="margin-left:20%;">This command fetches the count
of samples that are queued ahead of the first sample in the
most recent sample block written into its integer
argument.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_DRAIN</p>

<p style="margin-left:20%;">This command suspends the
calling process until all queued playback samples have been
played by the hardware.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETDEV
(audio_device_t)</p>

<p style="margin-left:20%;">This command fetches the
current hardware device information into the audio_device_t
argument.</p>

<p style="margin-left:20%; margin-top: 1em">typedef struct
audio_device { <br>
char name[MAX_AUDIO_DEV_LEN]; <br>
char version[MAX_AUDIO_DEV_LEN]; <br>
char config[MAX_AUDIO_DEV_LEN]; <br>
} audio_device_t;</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETFD
(int)</p>

<p style="margin-left:20%;">The command returns the current
setting of the full duplex mode.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETENC
(audio_encoding_t)</p>

<p style="margin-left:20%;">This command is used
iteratively to fetch sample encoding names and format_ids
into the input/output audio_encoding_t argument.</p>

<p style="margin-left:20%; margin-top: 1em">typedef struct
audio_encoding {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int index; /* input: nth encoding */</p></td>
<td width="55%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">char name[MAX_AUDIO_DEV_LEN]; /* name of
encoding */</p></td>
<td width="55%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int encoding; /* value for encoding
parameter */</p></td>
<td width="55%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int precision; /* value for precision
parameter */</p></td>
<td width="55%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int flags;</p></td>
<td width="55%">
</td>
</table>

<p style="margin-left:20%;">#define
AUDIO_ENCODINGFLAG_EMULATED 1 /* software emulation mode */
<br>
} audio_encoding_t;</p>

<p style="margin-left:20%; margin-top: 1em">To query all
the supported encodings, start with an index field of 0 and
continue with successive encodings (1, 2, ...) until the
command returns an error.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETFD
(int)</p>

<p style="margin-left:20%;">This command sets the device
into full-duplex operation if its integer argument has a
non-zero value, or into half-duplex operation if it contains
a zero value. If the device does not support full-duplex
operation, attempting to set full-duplex mode returns an
error.</p>
<p class=bad style="margin-left:20%;">
自VC の Full/Half 状態だけでなく
setfd インタフェースで HWの状態を直接変更している。
setfd インタフェースでデバッグ printf 以上のことをしている
MD ドライバは1つも存在しないので影響は顕在化しないが
本来はおかしいはず。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETPROPS
(int)</p>

<p style="margin-left:20%;">This command gets a bit set of
hardware properties. If the hardware has a certain property
the corresponding bit is set, otherwise it is not. The
properties can have the following values:</p>


<p style="margin-left:22%;margin-top: 1em" valign="top">AUDIO_PROP_FULLDUPLEX</p>

<p style="margin-left:27%">the device
admits full duplex operation.</p>

<p style="margin-left:22%">AUDIO_PROP_MMAP</p>

<p style="margin-left:27%">the device can
be used with mmap(2).</p>

<p style="margin-left:22%">AUDIO_PROP_INDEPENDENT</p>

<p style="margin-left:27%">the device can
set the playing and recording encoding parameters
independently.</p>

<p style="margin-left:22%">AUDIO_PROP_PLAYBACK</p>

<p style="margin-left:27%">the device is
capable of audio playback.</p>

<p style="margin-left:22%">AUDIO_PROP_CAPTURE</p>

<p style="margin-left:27%">the device is
capable of audio capture.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETIOFFS
(audio_offset_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETOOFFS
(audio_offset_t)</p>

<p style="margin-left:20%;">This command fetches the
current offset in the input(output) buffer where the audio
hardware&rsquo;s DMA engine will be putting(getting) data.
It mostly useful when the device buffer is available in user
space via the mmap(2) call. The information is returned in
the audio_offset structure.</p>

<p style="margin-left:20%; margin-top: 1em">typedef struct
audio_offset {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">samples; /* Total number of bytes
transferred */</p></td>
<td width="43%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">deltablks; /* Blocks transferred since last
checked */</p></td>
<td width="43%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">offset; /* Physical transfer offset in
buffer */</p></td>
<td width="43%">
</td>
</table>

<p style="margin-left:20%;">} audio_offset_t;</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETINFO
(audio_info_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETBUFINFO
(audio_info_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETINFO
(audio_info_t)</p>

<p style="margin-left:20%;">Get or set audio information as
encoded in the audio_info structure.</p>

<p style="margin-left:20%; margin-top: 1em">typedef struct
audio_info {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">struct</p></td>
<td width="12%">


<p valign="top">audio_prinfo play; /* info for play
(output) side */</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">struct</p></td>
<td width="12%">


<p valign="top">audio_prinfo record; /* info for record
(input) side */</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">


<p valign="top">u_int</p></td>
<td width="13%"></td>
<td width="12%">


<p valign="top">monitor_gain;</p></td>
<td width="12%"></td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="6%">


<p valign="top">/* input to output mix */</p></td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* BSD extensions */</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">blocksize;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* H/W read/write block size */</p></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">hiwat;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* output high water mark */</p></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">lowat;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* output low water mark */</p></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">_ispare1;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">mode;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* current device mode */</p></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">


<p valign="top">#define AUMODE_PLAY</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="12%">


<p valign="top">0x01</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">


<p valign="top">#define AUMODE_RECORD</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="12%">


<p valign="top">0x02</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">


<p valign="top">#define AUMODE_PLAY_ALL 0x04</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* do not do real-time correction */</p></td>
<td width="12%"></td>
<td width="6%">
</td>
</table>

<p style="margin-left:20%;">} audio_info_t;</p>

<p style="margin-left:20%; margin-top: 1em">When setting
the current state with AUDIO_SETINFO, the audio_info
structure should first be initialized with AUDIO_INITINFO
(&amp;info ) and then the particular values
to be changed should be set. This allows the audio driver to
only set those things that you wish to change and eliminates
the need to query the device with AUDIO_GETINFO or
AUDIO_GETBUFINFO first.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>mode</i>
field should be set to AUMODE_PLAY, AUMODE_RECORD,
AUMODE_PLAY_ALL, or a bitwise OR combination of the three.
Only full-duplex audio devices support simultaneous record
and playback.</p>

<p style="margin-left:20%; margin-top: 1em"><i>hiwat</i>
and <i>lowat</i> are used to control write behavior. Writes
to the audio devices will queue up blocks until the
high-water mark is reached, at which point any more write
calls will block until the queue is drained to the low-water
mark. <i>hiwat</i> and <i>lowat</i> set those high- and
low-water marks (in audio blocks). The default for
<i>hiwat</i> is the maximum value and for <i>lowat</i> 75 %
of <i>hiwat</i>.</p>


<p style="margin-left:20%; margin-top: 1em"><i>blocksize</i>
sets the current audio blocksize. The generic audio driver
layer and the hardware driver have the opportunity to adjust
this block size to get it within implementation-required
limits. Upon return from an AUDIO_SETINFO call, the actual
blocksize set is returned in this field. Normally the
<i>blocksize</i> is calculated to correspond to 50ms of
sound and it is recalculated when the encoding parameter
changes, but if the <i>blocksize</i> is set explicitly this
value becomes sticky, i.e., it remains even when the
encoding is changed. The stickiness can be cleared by
reopening the device or setting the <i>blocksize</i> to
0.</p>

<p style="margin-left:20%; margin-top: 1em">struct
audio_prinfo {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">sample_rate;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* sample rate in samples/s */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">channels;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* number of channels, usually 1 or 2
*/</p> </td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">precision;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* number of bits/sample */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">encoding;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* data encoding (AUDIO_ENCODING_* below)
*/</p> </td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">gain;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* volume level */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">port;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* selected I/O port */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_long</p></td>
<td width="12%">


<p valign="top">seek;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* BSD extension */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">avail_ports;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* available I/O ports */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">buffer_size;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* total size audio buffer */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">_ispare[1];</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">/* Current state of device: */</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">samples;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* number of samples */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_int</p></td>
<td width="12%">


<p valign="top">eof;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* End Of File (zero-size writes) counter
*/</p> </td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">pause;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* non-zero if paused, zero to resume
*/</p> </td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">error;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* non-zero if underflow/overflow occurred
*/</p> </td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">waiting;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* non-zero if another process hangs in
open */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">balance;</p></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">/* stereo channel balance */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">cspare[2];</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">open;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* non-zero if currently open */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">u_char</p></td>
<td width="12%">


<p valign="top">active;</p></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* non-zero if I/O is currently active
*/</p> </td>
<td width="18%">
</td>
</table>

<p style="margin-left:20%;">};</p>

<p class=bad style="margin-left:20%">
eof カウンタがデバイスごとに1つしかないので、
あるディスクリプタで eof カウンタが上がると別ディスクリプタでも同じ値が読める。
全 VC が閉じられるとリセットされる。
この変数になんの意味があるかはともかく、おそらく元の仕様の意図はそうではない。
</p>

<p style="margin-left:20%; margin-top: 1em">Note: many
hardware audio drivers require identical playback and
recording sample rates, sample encodings, and channel
counts. The playing information is always set last and will
prevail on such hardware. If the hardware can handle
different settings the AUDIO_PROP_INDEPENDENT property is
set.</p>

<p style="margin-left:20%; margin-top: 1em">The encoding
parameter can have the following values:</p>


<p style="margin-left:22%; margin-top: 1em" valign="top">AUDIO_ENCODING_ULAW</p>

<p style="margin-left:27%">mu-law
encoding, 8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_ALAW</p>

<p style="margin-left:27%">A-law encoding,
8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with the platform byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR</p>

<p style="margin-left:27%">unsigned linear
encoding with the platform byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ADPCM</p>

<p style="margin-left:27%">ADPCM encoding,
8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR_LE</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with little endian byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR_BE</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with big endian byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR_LE</p>

<p style="margin-left:27%">unsigned linear
encoding with little endian byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR_BE</p>

<p style="margin-left:27%">unsigned linear
encoding with big endian byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_AC3</p>

<p style="margin-left:27%">Dolby Digital
AC3</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>gain</i>, <i>port</i> and <i>balance</i> settings provide
simple shortcuts to the richer mixer interface described
below and are not obtained by AUDIO_GETBUFINFO. The gain
should be in the range [AUDIO_MIN_GAIN, AUDIO_MAX_GAIN] and
the balance in the range [AUDIO_LEFT_BALANCE,
AUDIO_RIGHT_BALANCE] with the normal setting at
AUDIO_MID_BALANCE.</p>

<p style="margin-left:20%; margin-top: 1em">The input port
should be a combination of:</p>


<p style="margin-left:22%; margin-top: 1em">AUDIO_MICROPHONE</p>

<p style="margin-left:27%">to select
microphone input.</p>

<p style="margin-left:22%">AUDIO_LINE_IN</p>

<p style="margin-left:27%">to select line
input.</p>

<p style="margin-left:22%">AUDIO_CD</p>

<p style="margin-left:27%">to select CD
input.</p>

<p style="margin-left:20%; margin-top: 1em">The output port
should be a combination of:</p>

<p style="margin-left:22%; margin-top: 1em">AUDIO_SPEAKER</p>

<p style="margin-left:27%">to select
speaker output.</p>

<p style="margin-left:22%">AUDIO_HEADPHONE</p>

<p style="margin-left:27%">to select
headphone output.</p>

<p style="margin-left:22%">AUDIO_LINE_OUT</p>

<p style="margin-left:27%">to select line
output.</p>

<p style="margin-left:20%; margin-top: 1em">The available
ports can be found in <i>avail_ports</i> (AUDIO_GETBUFINFO
only).</p>


<p style="margin-left:20%; margin-top: 1em"><i>buffer_size</i>
is the total size of the audio buffer. The buffer size
divided by the <i>blocksize</i> gives the maximum value for
<i>hiwat</i>. Currently the <i>buffer_size</i> can only be
read and not set.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>seek</i>
and <i>samples</i> fields are only used by AUDIO_GETINFO and
AUDIO_GETBUFINFO. <i>seek</i> represents the count of
samples pending; <i>samples</i> represents the total number
of bytes recorded or played, less those that were dropped
due to inadequate consumption/production rates.</p>

<p style="margin-left:20%; margin-top: 1em"><i>pause</i>
returns the current pause/unpause state for recording or
playback. For AUDIO_SETINFO, if the pause value is specified
it will either pause or unpause the particular
direction.</p>

<p style="margin-top: 1em" valign="top"><b>MIXER
DEVICE</b></p>

<p style="margin-left:8%;">The mixer device,
<i>/dev/mixer</i>, may be manipulated with ioctl(2) but does
not support read(2) or write(2). It supports the following
ioctl(2) commands:</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_GETDEV
(audio_device_t)</p>

<p style="margin-left:20%;">This command is the same as
described above for the sampling devices.</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_READ
(mixer_ctrl_t)</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_WRITE
(mixer_ctrl_t)</p>

<p style="margin-left:20%;">These commands read the current
mixer state or set new mixer state for the specified device
<i>dev</i>. <i>type</i> identifies which type of value is
supplied in the <i>mixer_ctrl_t</i> argument.</p>

<p style="margin-left:20%; margin-top: 1em">#define
AUDIO_MIXER_CLASS 0 <br>
#define AUDIO_MIXER_ENUM 1 <br>
#define AUDIO_MIXER_SET 2 <br>
#define AUDIO_MIXER_VALUE 3 <br>
typedef struct mixer_ctrl {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int dev;</p></td>
<td width="12%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">/* input: nth device */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">int type;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">union {</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">int ord;</p></td>
<td width="12%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">/* enum */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">int mask;</p></td>
<td width="12%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">/* set */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">mixer_level_t value;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%">


<p valign="top">/* value */</p></td>
<td width="6%">
</td>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="13%">


<p valign="top">} un;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="6%">
</td>
</table>

<p style="margin-left:20%;">} mixer_ctrl_t;</p>

<p style="margin-left:20%; margin-top: 1em">#define
AUDIO_MIN_GAIN 0 <br>
#define AUDIO_MAX_GAIN 255 <br>
typedef struct mixer_level { <br>
int num_channels; <br>
u_char level[8]; /* [num_channels] */ <br>
} mixer_level_t; <br>
#define AUDIO_MIXER_LEVEL_MONO 0 <br>
#define AUDIO_MIXER_LEVEL_LEFT 0 <br>
#define AUDIO_MIXER_LEVEL_RIGHT 1</p>

<p style="margin-left:20%; margin-top: 1em">For a mixer
value, the <i>value</i> field specifies both the number of
channels and the values for each channel. If the channel
count does not match the current channel count, the attempt
to change the setting may fail (depending on the hardware
device driver implementation). For an enumeration value, the
<i>ord</i> field should be set to one of the possible values
as returned by a prior AUDIO_MIXER_DEVINFO command. The type
AUDIO_MIXER_CLASS is only used for classifying particular
mixer device types and is not used for AUDIO_MIXER_READ or
AUDIO_MIXER_WRITE.</p>


<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_DEVINFO
(mixer_devinfo_t)</p>

<p style="margin-left:20%;">This command is used
iteratively to fetch audio mixer device information into the
input/output mixer_devinfo_t argument. To query all the
supported devices, start with an index field of 0 and
continue with successive devices (1, 2, ...) until the
command returns an error.</p>

<p style="margin-left:20%; margin-top: 1em">typedef struct
mixer_devinfo {</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">int index;</p></td>
<td width="12%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">/* input: nth mixer device */</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">audio_mixer_name_t label;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">int type;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">int mixer_class;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">int next, prev;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">


<p valign="top">#define AUDIO_MIXER_LAST</p></td>
<td width="13%"></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">-1</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">union {</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">struct audio_mixer_enum {</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int num_mem;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">struct {</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">audio_mixer_name_t label;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">int ord;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">} member[32];</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">} e;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">struct audio_mixer_set {</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int num_mem;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">struct {</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">audio_mixer_name_t label;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">int mask;</p></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">} member[32];</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">} s;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">struct audio_mixer_value {</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">audio_mixer_name_t units;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int num_channels;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">
</td>
<td width="12%">


<p valign="top">int delta;</p></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%">
</td>
<td width="13%">
</td>
<td width="12%">


<p valign="top">} v;</p></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">} un;</p></td>
<td width="12%"></td>
<td width="12%"></td>
<td width="13%"></td>
<td width="18%">
</td>
</table>

<p style="margin-left:20%;">} mixer_devinfo_t;</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>label</i> field identifies the name of this particular
mixer control. The <i>index</i> field may be used as the
<i>dev</i> field in AUDIO_MIXER_READ and AUDIO_MIXER_WRITE
commands. The <i>type</i> field identifies the type of this
mixer control. Enumeration types are typically used for
on/off style controls (e.g. a mute control) or for
input/output device selection (e.g. select recording input
source from CD, line in, or microphone). Set types are
similar to enumeration types but any combination of the mask
bits can be used.</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>mixer_class</i> field identifies what class of control
this is. The (arbitrary) value set by the hardware driver
may be determined by examining the <i>mixer_class</i> field
of the class itself, a mixer of type AUDIO_MIXER_CLASS. For
example, a mixer controlling the input gain on the line in
circuit would have a <i>mixer_class</i> that matches an
input class device with the name
&lsquo;&lsquo;inputs&rsquo;&rsquo; (AudioCinputs), and would
have a <i>label</i> of &lsquo;&lsquo;line&rsquo;&rsquo;
(AudioNline). Mixer controls which control audio circuitry
for a particular audio source (e.g. line-in, CD in, DAC
output) are collected under the input class, while those
which control all audio sources (e.g. master volume,
equalization controls) are under the output class. Hardware
devices capable of recording typically also have a record
class, for controls that only affect recording, and also a
monitor class.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>next</i>
and <i>prev</i> may be used by the hardware device driver to
provide hints for the next and previous devices in a related
set (for example, the line in level control would have the
line in mute as its &lsquo;&lsquo;next&rsquo;&rsquo; value).
If there is no relevant next or previous value,
AUDIO_MIXER_LAST is specified.</p>

<p style="margin-left:20%; margin-top: 1em">For
AUDIO_MIXER_ENUM mixer control types, the enumeration values
and their corresponding names are filled in. For example, a
mute control would return appropriate values paired with
AudioNon and AudioNoff. For AUDIO_MIXER_VALUE and
AUDIO_MIXER_SET mixer control types, the channel count is
returned; the units name specifies what the level controls
(typical values are AudioNvolume, AudioNtreble,
AudioNbass).</p>

<p style="margin-left:8%; margin-top: 1em">By convention,
all the mixer devices can be distinguished from other mixer
controls because they use a name from one of the AudioC*
string values.</p>

<p style="margin-top: 1em" valign="top"><b>FILES</b> <br>
<p style="margin-left:8%">
/dev/audio <br>
<p style="margin-left:8%">
/dev/audioctl <br>
<p style="margin-left:8%">
/dev/sound <br>
<p style="margin-left:8%">
/dev/mixer <br>

<p style="margin-top: 1em" valign="top"><b>SEE ALSO</b> <br>

<p style="margin-left:8%;">audioctl(1), mixerctl(1),
ioctl(2), ossaudio(3), midi(4), radio(4)<span class=n8>, sysctl(8)</span></p>

<p style="margin-left:8%; margin-top: 1em"><b>ISA bus</b>
<br>
aria(4), ess(4), gus(4), guspnp(4), pas(4), sb(4), wss(4),
ym(4)</p>

<p style="margin-left:8%; margin-top: 1em"><b>PCI bus</b>
<br>
auacer(4), auich(4), auixp(4), autri(4), auvia(4),
azalia(4), clcs(4), clct(4), cmpci(4), eap(4), emuxki(4),
esa(4), esm(4), eso(4), fms(4), neo(4), sv(4), yds(4)</p>


<p style="margin-left:8%; margin-top: 1em"><b>TURBOchannel</b>
<br>
bba(4)</p>

<p style="margin-left:8%; margin-top: 1em"><b>USB</b> <br>
uaudio(4)</p>

<p style="margin-top: 1em" valign="top"><span class=n7><b>BUGS</b></span></p>

<p class=n7 style="margin-left:8%;">If the device is used in mmap(2)
it is currently always mapped for writing (playing) due to
VM system weirdness.</p>

<p style="margin-top: 1em" valign="top"><span class=n8><b>HISTORY</b></span></p>
<p class=n8 style="margin-left:8%;">Support for virtual channels and
mixing first appeared in NetBSD&nbsp;8.0.</p>

<p style="margin-left:8%; margin-top: 1em">NetBSD&nbsp;7.1.1
September&nbsp;5, 2011 NetBSD&nbsp;7.1.1</p>
<hr>
</body>
</html>
