<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Wed Jan 17 22:02:35 2018 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<style type="text/css">
/*	color: rgb(255,40,0);	*/	/* 赤 */
/*	color: rgb(0,65,255);	*/	/* 青 */
/*	color: rgb(53,161,107);	*/	/* 緑 */
/*	color: rgb(255,209,209); */	/* ピンク */
/*	color: rgb(255,255,153); */	/* クリーム */

SPAN.n7 {
	background-color: rgb(255,255,153);	/* クリーム */
}

P.n7 {
	background-color: rgb(255,255,153);	/* クリーム */
}
P.n7:before {
	content: "(N7)";
	background-color: rgb(255,255,153);	/* クリーム */
	position: absolute;
	left: 5%;
}

SPAN.n8 {
	background-color: rgb(255,209,209);	/* ピンク */
}
P.n8 {
	background-color: rgb(255,209,209);	/* ピンク */
}
P.n8:before {
	content: "(N8)";
	background-color: rgb(255,209,209);	/* ピンク */
	position: absolute;
	left: 5%;
}

SPAN.n9 {
	background-color: rgb(180,235,250);	/* 明るい空色 */
}
P.n9 {
	background-color: rgb(180,235,250);	/* 明るい空色 */
}
P.n9:before {
	content: "(A2)";
	background-color: rgb(180,235,250);	/* 明るい空色 */
	position: absolute;
	left: 5%;
}

P.bad7 {
	color: rgb(255,153,0);	/* 橙色 */
	font-weight: bold;
}
P.bad7:before {
	content: "・";
}

SPAN.bad {
	color: rgb(255,40,0);	/* 赤 */
	font-weight: bold;
}
P.bad {
	color: rgb(255,40,0);	/* 赤 */
	font-weight: bold;
}
P.bad:before {
	content: "・";
}

SPAN.a2 {
	color: rgb(0,65,255);	/* 青 */
	font-weight: bold;
}
P.a2 {
	color: rgb(0,65,255);	/* 青 */
	font-weight: bold;
}
P.a2:before {
	content: "・";
}

P.comment {
	color: rgb(53,161,107);	/* 緑 */
	font-weight: bold;
}
P.comment:before {
	content: "・";
}

</style>
<title></title>
</head>
<body>
ベースにしたのは NetBSD 7.1 の audio.4,v 1.72。<br>
NetBSD 8 部分は audio.4,v 1.79。<br>
<p>
凡例:<br>
<p class=n7 style="margin-left:8%;">背景黄色の文章は NetBSD 7 から 8 になって削除されたところ。</p>
<p class=n8 style="margin-left:8%;">背景赤の文章は NetBSD 8 で追加されたところ。</p>
<p class=bad7 style="margin-left:8%;">橙太字は NetBSD 7 からある問題についてのコメント</p>
<p class=bad style="margin-left:8%;">赤太字は NetBSD 8 の問題についてのコメント</p>
<p class=a2 style="margin-left:8%;">青太字は AUDIO2 での仕様(案)。</p>
<p class=comment style="margin-left:8%;">緑太字はその他のコメント</p>

<hr>


<p valign="top">AUDIO(4) NetBSD Kernel Interfaces Manual
AUDIO(4)</p>

<p style="margin-top: 1em" valign="top"><b>NAME</b></p>

<p style="margin-left:8%;"><b>audio</b> &mdash;
device-independent audio driver layer</p>


<p style="margin-top: 1em" valign="top"><b>SYNOPSIS</b></p>

<p style="margin-left:8%;"><b>#include
&lt;sys/audioio.h&gt;</b></p>


<p style="margin-top: 1em" valign="top"><b>DESCRIPTION</b></p>

<p style="margin-left:8%;">The <b>audio</b> driver provides
support for various audio peripherals. It provides a uniform
programming interface layer above different underlying audio
hardware drivers. The audio layer provides full-duplex
operation if the underlying hardware configuration supports
it.</p>

<p style="margin-left:8%; margin-top: 1em">There are four
device files available for audio operation:
<i>/dev/audio</i>, <i>/dev/sound</i>, <i>/dev/audioctl</i>,
and <i>/dev/mixer</i>.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/audio</i>
and <i>/dev/sound</i> are used for recording or playback of
digital samples.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/mixer</i>
is used to manipulate volume, recording source, or other
audio mixer functions.</p>


<p style="margin-left:8%; margin-top: 1em"><i>/dev/audioctl</i>
accepts the same ioctl(2) operations as <i>/dev/sound</i>,
but no other operations.</p>

<p class=n7 style="margin-left:8%; margin-top: 1em">In contrast to
<i>/dev/sound</i> which has the exclusive open property
<i>/dev/audioctl</i> can be opened at any time and can be
used to manipulate the audio device while it is in use.</p>
<p class=n8 style="margin-left:8%;"><i>/dev/sound</i>
and <i>/dev/audio</i> can be opened at <i>any</i> time and
audio sources of different precision and playback parameters
i.e frequency will be mixed and played back
simultaneously.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em"><i>/dev/audioctl</i>
can be used to manipulate the audio device while it is in
use.</p>
<p class=bad style="margin-left:8%">
hw.*.multiuser == 0 下において、
/dev/audio か /dev/sound を誰かがオープンしていると、
他の人が /dev/audioctl をオープンできないバグがある。
また、逆、つまり /dev/audioctl を誰かがオープンしていると
他の人が /dev/audio か /dev/sound をオープンできないというバグもある。
hw.*.multiuser == 0 であっても /dev/audioctl は
/dev/audio、/dev/sound の状況に関わらず常にオープンできるのが仕様。
</p>


<p style="margin-top: 1em" valign="top"><b>SAMPLING
DEVICES</b></p>

<p style="margin-left:8%;">When <i>/dev/audio</i> is
opened, it automatically directs the underlying driver to
manipulate monaural 8-bit mu-law samples. In addition, if it
is opened read-only (write-only) the device is set to
half-duplex record (play) mode with recording (playing)
unpaused and playing (recording) paused.</p>
<p class=comment style="margin-left:8%">
Read-only でオープンしたら録音モードになって再生は pause に、
Write-only でオープンしたら再生モードになって録音は pause に、と
書いてあるが、この pause は AUDIO_GETINFO で取得できる pause ではなく、
意味的なもののようだ。紛らわしい。</p>
<p style="margin-left:8%">When
<i>/dev/sound</i> is opened, it maintains the previous audio
sample mode and record/playback mode <span class=n8>most recently set on
<i>/dev/sound</i> by any open channel</span>. In all other respects
<i>/dev/audio</i> and <i>/dev/sound</i> are identical.</p>
<p class=a2 style="margin-left:8%">
/dev/sound は直近の設定値を引き継ぐが、
N7 では /dev/audio に対する設定も /dev/sound の引き継ぎ対象に含まれる
(/dev/sound → /dev/audio → /dev/sound すると2回目の /dev/sound は
/dev/audio の設定値になる)。
N8 では /dev/audio に対する設定は引き継ぎ対象にならない
(先の例でいうと2回目の /dev/sound は1回目の /dev/sound の設定値になる)。
AUDIO2 では N7 の動作に準拠している。
</p>
<p class=a2 style="margin-left:8%">
ここでいう引き継ぎは AUDIO_SETINFO の以下のパラメータ。<br>
　o play.encoding<br>
　o play.precision<br>
　o play.channls<br>
　o play.sample_rate<br>
　o play.pause<br>
　o record.encoding<br>
　o record.precision<br>
　o record.channls<br>
　o record.sample_rate<br>
　o record.pause<br>
</p>

<p class=n7 style="margin-left:8%; margin-top: 1em">Only one process
may hold open a sampling device at a given time (although
file descriptors may be shared between processes once the
first open completes).</p>

<p style="background-color: rgb(255,209,209); margin-top: 1em" valign="top"><b>VIRTUAL
CHANNELS</b></p>
<p class=bad style="margin-left:0%">
名前がおかしい。
virtual でない channel はモノラルとか L とか R で、
virtual channel がオーディオストリームのことを指しているのは違和感がある。
</p>
<p class=a2 style="margin-left:0%">
AUDIO2 では、1つの再生または録音単位をトラックと呼ぶ。
1つ以内の再生と1つ以内の録音の組からなる1つのファイルディスクリプタに
対応するところの名前が未定。
</p>
<p class=a2 style="margin-left:0%">
あとセクションもここではない気がする。
</p>

<p class=n8 style="margin-left:8%;">Any process may open a sampling
device at a given time. Any number of devices per process
and file descriptors may be shared between processes.</p>
<p class=n9 style="margin-left:8%;">Any process may open a sampling
device at a given time. Any number of devices per process
and file descriptors may be shared between processes.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Virtual channels
are converted to a common format, signed linear encoding,
frequency channels and precision. These can be modified to
taste by the following sysctl(8) variables.</p>
<p class=bad style="margin-left:8%">
プローブ方法がだめだめすぎる。
</p>
<p class=bad style="margin-left:8%">
起動後に sysctl で変更できるが、HW で有効な選択肢は提示されない。</p>
<p class=bad style="margin-left:8%">
sysctl で HW で有効でない値をセットしてもエラーにならない。</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.precision</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.frequency</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.channels</p>

<p class=bad style="margin-left:12%; margin-top:1em">
そもそもこれらを sysctl で設定させるのがおかしい。</p>
<p class=a2 style="margin-left:12%">
AUDIO2 ではこの sysctl は採用しない。</p>


<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">hw.driverN.multiuser</p>
<p class=a2 style="margin-left:12%">
これは今の所引き継ぎ予定。
ただし名前は hw.audioN.multiuser にする。
</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Where
<i>driverN</i> corresponds to the underlying audio device
driver and device number. e.g In the case of an hdafg
supported device the variables would be: hw.hdafg0.channels,
hw.hdafg0.precision, hw.hdafg0.frequency.</p>
<p class=bad style="margin-left:8%">
hw.hdafg0.* のようなMD名ではなく hw.audio0.* を使うべき。
実際 hdafg(4) は hw.hdafg に独自の ioctl を持っているし、
そもそも今自分がアクセスしている audioN に対応する
MD デバイス名をプログラムから知る術が audio 側にない
(drvctl 使わないといけない?)。
</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">For best
results, values close to the underlying hardware should be
chosen. These variables may only be changed when the
sampling device is not in use.</p>
<p class=bad style="margin-left:8%">
ユーザにそれを選択させるとかおかしい。
</p>
<p class=a2 style="margin-left:8%">
この行は削除。
AUDIO2 では自動で選択する。
</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">An additional
sysctl(8) variable determines if multiple users are allowed
to access the sampling device, hw.driverN.multiuser.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">By default it is
set to false. This means that the sampling device may be
only used by <i>one</i> user at a time. Other users (except
root) attempting to open the sampling device will be
denied.</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">If set to true,
all users may access the sampling device at any time.</p>
<p class=comment style="margin-left:8%">
厳密に言えば、あるユーザがオープンしていても、
別のユーザもいつでもオープンできるということ。
</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Each virtual
channel has a corresponding mixer:</p>

<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">vchan.dacN Output
volume</p>

<p class=n8 style="margin-left:12%; margin-top: 1em" valign="top">vchan.micN
Recording volume</p>

<p class=n8 style="margin-left:8%; margin-top: 1em">Where N is the
virtual channel number. e.g vchan.dac0 controlling playback
volume and vchan.mic0 controlling recording volume for the
first virtual channel.</p>
<p class=a2 style="margin-left:8%">
AUDIO2 ではこのミキサパラメータはない。
</p>

<p style="margin-left:8%; margin-top: 1em">On a half-duplex
device, writes while recording is in progress will be
immediately discarded. Similarly, reads while playback is in
progress will be filled with silence but delayed to return
at the current sampling rate. If both playback and recording
are requested on a half-duplex device, playback mode takes
precedence and recordings will get silence.</p>
<p class=bad style="margin-left:8%">
N8 では Half-Duplex HW に対して open(O_WRONLY) してwrite()と、
open(O_RDONLY) して read を同時に行うと read がブロックするようだ。
</p>

<p style="margin-left:8%; margin-top: 1em">On a full-duplex
device, reads and writes may operate concurrently without
interference. If a full-duplex capable audio device is
opened for both reading and writing it will start in
half-duplex play mode; full-duplex mode has to be set
explicitly.</p>
<p class=bad7 style="margin-left:8%">
2文目
「Full-duplex 対応オーディオデバイスは reading または writing の
どちらでオープンされても、half-duplex 再生モードになる。
full-duplex モードには明示的にセットする必要がある」
とあるが、
N7、N8 いずれも現在の実装での挙動は以下の通り。<br>
open(O_RDONLY) は Full/Half-Duplex どちらの HW でも half-duplex 録音モード、<br>
open(O_WRONLY) は Full/Half-Duplex どちらの HW でも half-duplex 再生モード、<br>
open(O_RDWR) は Half-Duplex HW では half-duplex 再生モード、
Full-Duplex HW では full-duplex 再生録音モード(?)になる。<br>
これはこれで manpage を修正したほうがいい。
</p>
<p class=a2 style="margin-left:8%">
AUDIO2 では<br>
Full-Duplex HW については<br>
o open(O_RDONLY) なら half-duplex 録音モード(従来通り)、<br>
o open(O_WRONLY) なら half-duplex 再生モード(従来通り)、<br>
o open(O_RDWR) なら full-duplex 再生録音モード(?) (従来の実装通り)、<br>
Half-Duplex HW については<br>
o open(O_RDONLY) はすでに再生モードの人がいればエラー、いなければ
half-duplex 録音モード、<br>
o open(O_WRONLY) はすでに録音モードの人がいればエラー、いなければ
half-duplex 再生モード、<br>
o open(O_RDWR) はすでに録音モードの人がいればエラー、いなければ
half-duplex 再生モード、<br>
と定義したい。
Half HW の「O_RDWR を再生側に倒す」という考え方は従来仕様にならったもの。
</p>



<p style="margin-left:8%; margin-top: 1em">On either type
of device, if the playback mode is paused then silence is
played instead of the provided samples, and if recording is
paused then the process blocks in read(2) until recording is
unpaused.</p>

<p style="margin-left:8%; margin-top: 1em">If a writing
process does not call write(2) frequently enough to provide
samples at the pace the hardware consumes them silence is
inserted. If the AUMODE_PLAY_ALL mode is not set the writing
process must provide enough data via subsequent write calls
to &lsquo;&lsquo;catch up&rsquo;&rsquo; in time to the
current audio block before any more process-provided samples
will be played. If a reading process does not call read(2)
frequently enough, it will simply miss samples.</p>
<p class=a2 style="margin-left:8%">
この段落は
If a writing
process does not call write(2) frequently enough to provide
samples at the pace the hardware consumes them silence is
inserted.
If a reading process does not call read(2)
frequently enough, it will simply miss samples.
としたい (AUMODE_PLAY_ALL に関する文を削除)。</p>

<p style="margin-left:8%; margin-top: 1em">The audio device
is normally accessed with read(2) or write(2) calls, but it
can also be mapped into user memory with mmap(2) <span class=n7>(when
supported by the device)</span>. Once the device has been mapped it
can no longer be accessed by read or write; all access is by
reading and writing to the mapped memory.
</p>
<p class=bad7 style="margin-left:8%">
「mmap されると read や write によるアクセスはすべて出来なくなる」
ように読めるが、
実際には mmap されるのは再生バッファだけで、
この制限が録音バッファのほうには及んでいない。
そのため (O_RDWR なら) mmap した後も read は発行できる。
バグなのか仕様なのか。
</p>
<p class=a2 style="margin-left:8%">
AUDIO2 でも今のところ同じ動作 (read は行える) になる。
</p>
<p class=a2 style="margin-left:8%">
その時の write の
エラーコードが従来 EINVAL (Invalid Argument) だったが、
EPERM (Operation not permitted) のほうがいいんじゃないかと思うので変えてみる。
</p>
<p style="margin-left:8%">
The device appears
as a block of memory of size <i>buffersize</i> (as available
via AUDIO_GETINFO or AUDIO_GETBUFINFO). The device driver
will continuously move data from this buffer from/to the
audio hardware, wrapping around at the end of the buffer. To
find out where the hardware is currently accessing data in
the buffer the AUDIO_GETIOFFS and AUDIO_GETOOFFS calls can
be used. The playing and recording buffers are distinct and
must be mapped separately if both are to be used.
</p>
<p class=bad7 style="margin-left:8%">
本来は再生バッファを PROT_WRITE、録音バッファを PROT_READ で別々に
mmap させるつもりだったようだが、
VM あたりの制約によりこれが実現できず、今はこのフラグに関係なく
常に再生バッファの mmap のみ可能。
もう manpage の記載を修正したほうがいいのでは。
</p>
<p style="margin-left:8%">
Only
encodings that are not emulated (i.e. where
AUDIO_ENCODINGFLAG_EMULATED is not set) work properly for a
mapped device.</p>
<p class=bad style="margin-left:8%">
N8 では AUDIO_ENCODINGFLAG_EMULRATED の有無に関わらず mmap は動作するので
この一文は正しくない。
</p>
<p class=a2 style="margin-left:8%">
AUDIO2 でも同様なので、この一文は削除していいのでは。
</p>

<p style="margin-left:8%; margin-top: 1em">The audio
device, like most devices, can be used in <i>select</i>, can
be set in non-blocking mode and can be set (with a FIOASYNC
ioctl) to send a SIGIO when I/O is possible. The mixer
device can be set to generate a SIGIO whenever a mixer value
is changed.</p>
<p class=bad style="margin-left:8%">
FIOASYNC が VC 分離されていない。
プロセスAが FIOASYNC を on にしても、
別のプロセスBが(ユーザにも特権にも関係なく) FIOASYNC を off にできる。
また FIOASYNC がリセットされるのは再生+録音の最終クローズ時であるため、
プロセスAがデバイスをオープンしたまま
別のプロセスBが FIOASYNC をセットしてクローズしても
まだ FIOASYNC がリセットされず、次にオープンしても FIOASYNC をセットできない。
</p>
<p class=a2 style="margin-left:8%">
AUDIO2 では修正済み。
FIOASYNC はファイルディスクリプタごとに独立している。
</p>

<p style="margin-left:8%; margin-top: 1em">The following
ioctl(2) commands are supported on the sample devices:</p>

<p class=n8 style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETCHAN
(int)</p>

<p class=n8 style="margin-left:20%;">This command will return the
audio channel in use.</p>

<p class=n8 style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETCHAN
(int)</p>

<p class=n8 style="margin-left:20%;">This command will select the
audio channel for subsequent ioctl calls.</p>
<p class=bad style="margin-left:20%">
(ユーザにも特権にも関係なく) 他のVCを指定することができて
(その後の ioctl でその VC の状態を変更できて) しまうのでセキュリティ上アウト
→ <a href="http://gnats.netbsd.org/52627">kern/52627</a></p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではこの2つの ioctl は廃止。必要ない。
</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_FLUSH</p>

<p style="margin-left:20%;">This command stops all playback
and recording, clears all queued buffers, resets error
counters, and restarts recording and playback as appropriate
for the current sampling mode.</p>
<p class=bad style="margin-left:20%">
stops all playback and recoring は他のVCにも影響を与えるように読めないだろうか。
</p>
<p class=a2 style="margin-left:20%">
「stops all playback and recoring」→
「このディスクリプタ(?)の再生と録音をすべて停止」とか、
影響がこれだけであることは明確にしておきたい。</p>
<p class=comment style="margin-left:20%">
ここでいうエラーカウンタはドロップ数 AUDIO_[PR]ERROR の値を指す。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top"><span class=a2
>AUDIO_PERROR (int)</span></p>

<p style="margin-left:20%"><span class=a2>This command fetches the count
of dropped output bytes into its integer argument. There is
no information regarding when in the sample stream they were
dropped.</span></p>
<p class=bad7 style="margin-left:20%">
この ioctl は以前から実装されているが、
manpage には AUDIO_RERROR だけあって AUDIO_PERROR が抜けている。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_RERROR
(int)</p>

<p style="margin-left:20%;">This command fetches the count
of dropped input samples into its integer argument. There is
no information regarding when in the sample stream they were
dropped.</p>
<p class=a2 style="margin-left:20%">サンプル数と書いてあるが、
バイト数を返すことにしたい。</p>
<p class=comment style="margin-left:20%">たしかそんな PR が出てた気がする。</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_WSEEK
(u_long)</p>

<p style="margin-left:20%;">This command fetches the count
of samples that are queued ahead of the first sample in the
most recent sample block written into its integer
argument.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_DRAIN</p>

<p style="margin-left:20%;">This command suspends the
calling process until all queued playback samples have been
played by the hardware.</p>
<p class=bad style="margin-left:20%">
x68k くらいの遅マシンでは drain の挙動がなんか変。</p>
<p class=a2 style="margin-left:20%">
AUDIO2 では問題ない。
ただし VirtualBox はエミュレーション精度が甘いので実機通りにはならない可能性があることは分かっている(がこっちの問題ではない)。
</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETDEV
(audio_device_t)</p>

<p style="margin-left:20%;">This command fetches the
current hardware device information into the audio_device_t
argument.</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_device {
	char name[MAX_AUDIO_DEV_LEN];
	char version[MAX_AUDIO_DEV_LEN];
	char config[MAX_AUDIO_DEV_LEN];
} audio_device_t;</pre>
</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETENC
(audio_encoding_t)</p>

<p style="margin-left:20%;">This command is used
iteratively to fetch sample encoding names and format_ids
into the input/output audio_encoding_t argument.</p>
<p class=bad style="margin-left:20%">
N7 までは MD がサポートしているエンコーディングと
ユーザランドから入出力できるエンコーディングとが一致していたからよかったが、
N8 ではそれが一致しなくなったため、AUDIO_GETENC が何を(どちらを)
返すべきものなのかを再定義するなり何なりの対応をしなければいけないが、
そうはなっていない。
というか、今はそのどちらでもないよくわからん集合が返ってくる。
→ <a href="https://gnats.netbsd.org/52585">kern/52585</a>
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 では、
AUDIO_GETENC は MI がユーザランドから受け付けるエンコーディングを列挙する
ものとし、
ハードウェアが対応しているエンコーディングは新設の AUDIO_QUERYFORMAT
で列挙できるようにしてみたが、どうだろう。
</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_encoding {
	int index;			/* input: nth encoding */
	char name[MAX_AUDIO_DEV_LEN];	/* name of encoding */
	int encoding;			/* value for encoding parameter */
	int precision;			/* value for precision parameter */
	int flags;
#define AUDIO_ENCODINGFLAG_EMULATED 1	/* software emulation mode */
} audio_encoding_t;</pre>
</p>

<p style="margin-left:20%; margin-top: 1em">To query all
the supported encodings, start with an index field of 0 and
continue with successive encodings (1, 2, ...) until the
command returns an error.</p>


<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETFD
(int)</p>

<p style="margin-left:20%;">The command returns the current
setting of the full duplex mode.</p>
<p class=a2 style="margin-left:20%">
元の manpage はなぜか AUDIO_GETFD、AUDIO_GETENC、AUDIO_SETFD の順に並んでいて
読みにくいので、AUDIO_GETFD を AUDIO_SETFD の近くに移動した。
</p>
<p class=a2 style="margin-left:20%">
このコマンドはディスクリプタが full duplex かどうかを返す。
HW の状態ではない。
HW が Full duplex でかつディスクリプタが O_RDWR でオープンされていれば
full duplex、それ以外は half duplex とする。
</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETFD
(int)</p>

<p style="margin-left:20%;">This command sets the device
into full-duplex operation if its integer argument has a
non-zero value, or into half-duplex operation if it contains
a zero value. If the device does not support full-duplex
operation, attempting to set full-duplex mode returns an
error.</p>
<p class=bad style="margin-left:20%;">
自VC の Full/Half 状態だけでなく
hw_if-&gt;setfd で HWの状態を直接変更している。
hw_if-&gt;setfd でデバッグ printf 以上のことをしている
MD ドライバは1つも存在しないので影響は顕在化しないが
本来はおかしい。</p>
<p class=comment style="margin-left:20%">
本来 open 直後は必ず Half duplex 状態になっており
その後必要ならこの ioctl で Full duplex に変える
という運用を想定していたようだが(少なくともこの manpage の最初のほうにそう書いてある)、
実装のほうは open 直後から(可能なら) Full duplex になるようになっている。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではオープン時に確定した Full/Half 状態を
オープン後に変更することは禁止したいので、
実質この ioctl は obsolete とする。
ただし後方互換性のため、
現在 Full duplex の時の引数非ゼロ(Full duplex への変更)と、
現在 Half duplex の時の引数ゼロ(Half duplex への変更)は
影響がないので成功し、
それ以外はエラー ENOTTY になる、とする。
</p>
<p class=a2 style="margin-left:20%">
Full duplex を Half duplex に変更することが出来なくなるが、
意図や使い道が分からないし、たぶん困らないだろう。
</p>


<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETPROPS
(int)</p>

<p style="margin-left:20%;">This command gets a bit set of
hardware properties. If the hardware has a certain property
the corresponding bit is set, otherwise it is not. The
properties can have the following values:</p>


<p style="margin-left:22%;margin-top: 1em" valign="top">AUDIO_PROP_FULLDUPLEX</p>

<p style="margin-left:27%">the device
admits full duplex operation.</p>

<p style="margin-left:22%">AUDIO_PROP_MMAP</p>

<p style="margin-left:27%">the device can
be used with mmap(2).</p>
<p class=bad style="margin-left:27%">
N8 ではこのフラグはハードウェアプロパティではなくなっているが
(ソフトウェアエミュレーションに近い)、どうしたものか。
</p>
<p class=a2 style="margin-left:27%">
AUDIO2 でも同様。
</p>

<p style="margin-left:22%">AUDIO_PROP_INDEPENDENT</p>

<p style="margin-left:27%">the device can
set the playing and recording encoding parameters
independently.</p>

<p style="margin-left:22%">AUDIO_PROP_PLAYBACK</p>

<p style="margin-left:27%">the device is
capable of audio playback.</p>

<p style="margin-left:22%">AUDIO_PROP_CAPTURE</p>

<p style="margin-left:27%">the device is
capable of audio capture.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETIOFFS
(audio_offset_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETOOFFS
(audio_offset_t)</p>

<p style="margin-left:20%;">This command fetches the
current offset in the input(output) buffer where the audio
hardware&rsquo;s DMA engine will be putting(getting) data.
</p>
<p class=bad style="margin-left:20%">
少なくとも N8 以降はハードウェアとか DMA 関係なくなってきてる気がする。
</p>
<p style="margin-left:20%">
It mostly useful when the device buffer is available in user
space via the mmap(2) call. The information is returned in
the audio_offset structure.</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_offset {
	u_int	samples;	/* Total number of bytes transferred */
	u_int	deltablks;	/* Blocks transferred since last checked */
	u_int	offset;		/* Physical transfer offset in buffer */
}</pre></p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETINFO
(audio_info_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_GETBUFINFO
(audio_info_t)</p>

<p style="margin-left:12%;margin-top: 1em" valign="top">AUDIO_SETINFO
(audio_info_t)</p>

<p style="margin-left:20%;">Get or set audio information as
encoded in the audio_info structure.</p>
<p class=bad7 style="margin-left:20%">
設定項目が多いので設定中にエラーが起きると本来は全部ロールバックしないと
いけないような気がするのと最初期の頃(20年前)のソースは一応その辺も
意識してあったように見えるが、
その後すぐに複雑になりすぎてロールバックは一切お察しのような気がする。</p>
<p class=a2 style="margin-left:20%">
一応エラーの際には完全にロールバックを目指すようには作ってみたが、
今まで10年以上ロールバックしない動作だったので逆に問題になるかも知れない。
一度にあれこれ設定してもどれがエラーになったか判別できないため、
その辺ちゃんと考えてるアプリなら必然的に一つずつ SETINFO しては
エラーチェックするというコードになりがちなため、
メジャー処では問題は起きなさそうだけど。
</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">typedef struct audio_info {
	struct audio_prinfo play;	/* info for play (output) side */
	struct audio_prinfo record;	/* info for record (input) side */
	u_int	monitor_gain;		/* input to output mix */

	/* BSD extensions */
	u_int	blocksize;		/* H/W read/write block size */
	u_int	hiwat;			/* output high water mark */
	u_int	lowat;			/* output low water mark */
	u_int	_ispare1;
	u_int	mode;			/* current device mode */
#define AUMODE_PLAY	0x01
#define AUMODE_RECORD	0x02
#define AUMODE_PLAY_ALL	0x04		/* do not do real-time correction */
<span class=a2>#define AUMODE_PLAY_ALL	0x04		/* Not used anymore in AUDIO2 */</span>
} audio_info_t;</pre>
</p>

<p style="margin-left:20%; margin-top: 1em">When setting
the current state with AUDIO_SETINFO, the audio_info
structure should first be initialized with AUDIO_INITINFO
(&amp;info ) and then the particular values
to be changed should be set. This allows the audio driver to
only set those things that you wish to change and eliminates
the need to query the device with AUDIO_GETINFO or
AUDIO_GETBUFINFO first.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>mode</i>
field should be set to AUMODE_PLAY, AUMODE_RECORD,
AUMODE_PLAY_ALL, or a bitwise OR combination of the three.
Only full-duplex audio devices support simultaneous record
and playback.</p>
<p class=bad7 style="margin-left:20%">
mode には何がセットされていてもこの ioctl がエラーにはならない。
ただし次に AUDIO_GETINFO してみて何が取得できるかとはまったく別。
そしてここで取得できる mode はセット後の何の動作にはまったく影響しないようだ。
分かりにくすぎというかバグでは。
</p>
<p class=a2 style="margin-left:20%">
指定された mode に設定変更できなければ EINVAL なり何なりのエラーにしたい
ところだが、従来との互換性を考えて ioctl はエラーにはしない。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではオープン後の録音再生方向の変更を認めていない。
また AUMODE_PLAY_ALL ビットも実質意味を持たなくなったため、
AUDIO_SETINFO の mode 設定は単に無視される。
ただし互換性のため再生モードでの AUMODE_PLAY_ALL ビットの状態は保持する。
</p>

<p style="margin-left:20%; margin-top: 1em"><i>hiwat</i>
and <i>lowat</i> are used to control write behavior. Writes
to the audio devices will queue up blocks until the
high-water mark is reached, at which point any more write
calls will block until the queue is drained to the low-water
mark. <i>hiwat</i> and <i>lowat</i> set those high- and
low-water marks (in audio blocks). The default for
<i>hiwat</i> is the maximum value and for <i>lowat</i> 75 %
of <i>hiwat</i>.</p>

<p style="margin-left:20%; margin-top: 1em"><i>blocksize</i>
sets the current audio blocksize. The generic audio driver
layer and the hardware driver have the opportunity to adjust
this block size to get it within implementation-required
limits. Upon return from an AUDIO_SETINFO call, the actual
blocksize set is returned in this field. Normally the
<i>blocksize</i> is calculated to correspond to 50ms of
sound and it is recalculated when the encoding parameter
changes, but if the <i>blocksize</i> is set explicitly this
value becomes sticky, i.e., it remains even when the
encoding is changed. The stickiness can be cleared by
reopening the device or setting the <i>blocksize</i> to
0.</p>
<p class=bad7 style="margin-left:20%">
AUDIO_SETINFO は実際にセットした blocksize を書き戻すと manpage
には書いてあるが、N7もN8も書き戻しを行なっていない。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 では hardware driver がブロックサイズを変更する機会は今の所たぶん持たない。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 でも AUDIO_SETINFO による blocksize の書き戻しは行わない予定。
manpage のほうを修正したほうがいい。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではブロックサイズはデフォルトで 40msec 分のサイズになるようにしてある。
ただし HW の制約により 40msec で問題がある場合は
問題のないところまで自動で拡張する。
これがおきるのは今の所 4bit precision である x68k の vs(4) だけ。
</p>
<p class=a2 style="margin-left:20%">
エンコーディングを変更するとブロックサイズは常に追従する。
スティッキーモードは実装しない予定。
</p>
<p class=a2 style="margin-left:20%">
元々この構造体の blocksize は録音再生の区別がないが、
AUDIO2 では録音トラックと再生トラックの blocksize は同じとは限らない。
現在のディスクリプタが再生のみなら再生 blocksize を、
録音のみなら録音 blocksize を返すが、録音再生が同時に有効な場合は仕方ないので
再生 blocksize を返す。
どうしたもんだかこれ。
</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">struct audio_prinfo {
	u_int	sample_rate;	/* sample rate in samples/s */
	u_int	channels;	/* number of channels, usually 1 or 2 */
	u_int	precision;	/* number of bits/sample */
	u_int	encoding;	/* data encoding (AUDIO_ENCODING_* below) */
	u_int	gain;		/* volume level */
	u_int	port;		/* selected I/O port */
	u_long	seek;		/* BSD extension */
	u_int	avail_ports;	/* available I/O ports */
	u_int	buffer_size;	/* total size audio buffer */
	u_int	_ispare[1];	/* Current state of device: */
	u_int	samples;	/* number of samples */
	u_int	eof;		/* End Of File (zero-size writes) counter */
	u_char	pause;		/* non-zero if paused, zero to resume */
	u_char	error;		/* non-zero if underflow/overflow occurred */
	u_char	waiting;	/* non-zero if another process hangs in open */
	u_char	balance;	/* stereo channel balance */
	u_char	cspare[2];
	u_char	open;		/* non-zero if currently open */
	u_char	active;		/* non-zero if I/O is currently active */
};</pre>
</p>

<p class=bad7 style="margin-left:20%">
sample_rate = 0 を設定すると、システムコールが無限ループになって(?)
帰ってこない。
shutdown も出来なくなる。
ここまでは N7 以前でも起きる。
<span class=bad>
N7 以前ならオーディオデバイスを開けるのは高々1人なので
それ以上影響は広がらないが、N8 だといくらでもオープンできるので以下略。
</span>
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではカーネルが受け付ける sample_rate を
1000Hz から 192000Hz までと定義した。
hdaudio(4) が規格上 384kHz とか扱えるらしいけど、誰か検証よろしく。
</p>
<p class=bad style="margin-left:20%">
eof カウンタが VC 分離できていない。
あるディスクリプタで eof カウンタが上がると別ディスクリプタでも同じ値が読める。
全 VC が閉じられるとリセットされる。
この変数になんの意味があるかはともかく、おそらく元の仕様の意図はそうではない。
</p>
<p class=a2 style="margin-left:20%">
eof カウンタはファイルディスクリプタごとにした。
</p>

<p style="margin-left:20%; margin-top: 1em">Note: many
hardware audio drivers require identical playback and
recording sample rates, sample encodings, and channel
counts. The playing information is always set last and will
prevail on such hardware. If the hardware can handle
different settings the AUDIO_PROP_INDEPENDENT property is
set.</p>

<p style="margin-left:20%; margin-top: 1em">The encoding
parameter can have the following values:</p>


<p style="margin-left:22%; margin-top: 1em" valign="top">AUDIO_ENCODING_ULAW</p>

<p style="margin-left:27%">mu-law
encoding, 8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_ALAW</p>

<p style="margin-left:27%">A-law encoding,
8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with the platform byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR</p>

<p style="margin-left:27%">unsigned linear
encoding with the platform byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ADPCM</p>

<p style="margin-left:27%">ADPCM encoding,
8 bits/sample</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR_LE</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with little endian byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_SLINEAR_BE</p>

<p style="margin-left:27%">two&rsquo;s
complement signed linear encoding with big endian byte
order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR_LE</p>

<p style="margin-left:27%">unsigned linear
encoding with little endian byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_ULINEAR_BE</p>

<p style="margin-left:27%">unsigned linear
encoding with big endian byte order</p>

<p style="margin-left:22%">AUDIO_ENCODING_AC3</p>

<p style="margin-left:27%">Dolby Digital
AC3</p>

<p class=bad style="margin-left:20%">
ユーザランドから受け付けるエンコーディングは N7 までと異なり
MI で一元的に扱うようになったが、どれを受け付けるのかはソース嫁状態。
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 では以下を受け付ける。
また、この一覧は AUDIO_GETENC で取得できる。<br>
　o AUDIO_ENCODING_SLINEAR_{LE,BE} 8, 16, 32 bit<br>
　o AUDIO_ENCODING_ULINEAR_{LE,BE} 8, 16, 32 bit<br>
　o AUDIO_ENCODING_ULAW 8bit<br>
</p>
<p class=a2 style="margin-left:20%">
24/24 はデフォルト受け付けなくても誰も困らないだろう。
(今の所) audiovar.h の AUDIO_SUPPORT_LINEAR24 を on にすれば受け付ける。
カーネルオプションにはしてもいいかも。
これを足すと amd64 で 1300バイトだけ text segment が増える。
32bit も要るのかなあという気はしないでもないが。
</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>gain</i>, <i>port</i> and <i>balance</i> settings provide
simple shortcuts to the richer mixer interface described
below and are not obtained by AUDIO_GETBUFINFO. The gain
should be in the range [AUDIO_MIN_GAIN, AUDIO_MAX_GAIN] and
the balance in the range [AUDIO_LEFT_BALANCE,
AUDIO_RIGHT_BALANCE] with the normal setting at
AUDIO_MID_BALANCE.</p>
<p class=bad style="margin-left:20%">
balance と gain は元々セットで HW ミキサーを指していたが、
このうち gain の設定だけ VC のマスターボリュームの変更に書き換えられ、
gain の取得と balance の設定・取得は HW ミキサーのままなので、いろいろ整合していない。
PR が出ている → <a href="https://gnats.netbsd.org/52781">kern/52781</a>
</p>
<p class=a2 style="margin-left:20%">
AUDIO2 では N7 同様 HW ミキサーを指すように修正。
</p>

<p style="margin-left:20%; margin-top: 1em">The input port
should be a combination of:</p>


<p style="margin-left:22%; margin-top: 1em">AUDIO_MICROPHONE</p>

<p style="margin-left:27%">to select
microphone input.</p>

<p style="margin-left:22%">AUDIO_LINE_IN</p>

<p style="margin-left:27%">to select line
input.</p>

<p style="margin-left:22%">AUDIO_CD</p>

<p style="margin-left:27%">to select CD
input.</p>

<p style="margin-left:20%; margin-top: 1em">The output port
should be a combination of:</p>

<p style="margin-left:22%; margin-top: 1em">AUDIO_SPEAKER</p>

<p style="margin-left:27%">to select
speaker output.</p>

<p style="margin-left:22%">AUDIO_HEADPHONE</p>

<p style="margin-left:27%">to select
headphone output.</p>

<p style="margin-left:22%">AUDIO_LINE_OUT</p>

<p style="margin-left:27%">to select line
output.</p>

<p style="margin-left:20%; margin-top: 1em">The available
ports can be found in <i>avail_ports</i> (AUDIO_GETBUFINFO
only).</p>


<p style="margin-left:20%; margin-top: 1em"><i>buffer_size</i>
is the total size of the audio buffer. The buffer size
divided by the <i>blocksize</i> gives the maximum value for
<i>hiwat</i>. Currently the <i>buffer_size</i> can only be
read and not set.</p>
<p class=a2 style="margin-left:20%">
AUDIO2 ではオープンしていない方のトラック
(例えば O_WRONLY でオープンした場合の録音側) の buffer_size は 0 になる。
N7 および N8 では常にどちらも 0 でないバッファサイズが返されると思う。
これは、N7/N8 実装は録音再生がそこまで独立した構造にはなっておらず
(たぶん)常に両方のバッファを確保しているため。
一方 AUDIO2 実装では録音と再生を明確に分離し、
使わないほうのトラックは一切リソースを確保していないためである。
</p>


<p style="margin-left:20%; margin-top: 1em">The <i>seek</i>
and <i>samples</i> fields are only used by AUDIO_GETINFO and
AUDIO_GETBUFINFO. <i>seek</i> represents the count of
samples pending; <i>samples</i> represents the total number
of bytes recorded or played, less those that were dropped
due to inadequate consumption/production rates.</p>
<p class=a2 style="margin-left:20%">
seek はサンプル数とあるがバイト数にしたい。
</p>

<p style="margin-left:20%; margin-top: 1em"><i>pause</i>
returns the current pause/unpause state for recording or
playback. For AUDIO_SETINFO, if the pause value is specified
it will either pause or unpause the particular
direction.</p>

<p style="margin-left:12%;margin-top: 1em" valign="top"
><span class=a2>AUDIO_QUERYFORMAT (audio_format_query_t)</span></p>
<p style="margin-left:20%;"><span class=a2>
AUDIO2 新設 ioctl。
ハードウェアがサポートしているフォーマットを取得する。
<tt>AUDIO_GETENC</tt> と似ていて index を指定して audio_format を取得する。
index を 0 から始めて ENOENT が返ってくるまで繰り返すと全フォーマットが取得
できる。
</p>
<pre style="margin-left:20%"><span class=a2>typedef struct audio_format_query {
	u_int	index;
	struct audio_format fmt;
} audio_format_query_t;
</span></pre>
<p class=a2 style="margin-left:20%;">AUDIO_GETENC で使う
audio_encoding_t はチャンネル数および周波数情報が返せないため、
新しい構造体と ioctl を用意した。
</p>
<p class=a2 style="margin-left:20%;">
今の所ハードウェアがサポートしているフォーマットをすべて返すが、
このうちトラックミキサーが対応しているのは SLINEAR_NE:16bit
(ビット数は AUDIO_INTERNAL_BITS コンパイル時定数による)
のフォーマットのみである。
この辺どのレイヤでマスクするかという考察課題はある。
フォーマットが全部見えると HW 特性を知るのに便利なような気もするし。
</p>
<p class=a2 style="margin-left:20%;">
デバイスが query_format インタフェースをサポートしていない場合は、
ENODEV を返すにしてみたがどうか。
</p>

<p style="margin-left:12%;margin-top: 1em" valign="top"><span class=a2
>AUDIO_GETFORMAT (audio_info_t)</span></p>
<p style="margin-left:12%;margin-top: 1em" valign="top"><span class=a2>
AUDIO_SETFORMAT (audio_info_t)</span></p>
<p style="margin-left:20%;"><span class=a2>
AUDIO2 新設 ioctl。
現在のトラックミキサのフォーマットを取得あるいは設定する。
いずれの場合も audio_info_t のうち以下のメンバだけを使用する。
play、record のうちサポートしていない側 (再生専用デバイスの録音側など)の
メンバと、ここに記載のないメンバは
GETFORMAT 時はゼロで埋められ、SETFORMAT 時は無視する。
</span></p>
<ul style="margin-left:20%; margin-top:0; margin-bottom:0;">
<li><span class=a2>mode</span>
<li><span class=a2>play.encoding</span>
<li><span class=a2>play.precision</span>
<li><span class=a2>play.channels</span>
<li><span class=a2>play.sample_rate</span>
<li><span class=a2>record.encoding</span>
<li><span class=a2>record.precision</span>
<li><span class=a2>record.channels</span>
<li><span class=a2>record.sample_rate</span>
</ul>
<p style="margin-left:20%;margin-top:0;"><span class=a2>
<tt>AUDIO_SETFORMAT</tt> は再生および録音ディスクリプタが一つもない状態で
なければならない。
</span></p>
<p class=a2 style="margin-left:20%">
independent デバイスであっても、例えば再生中に録音ミキサのフォーマットだけを
変えることは出来ない。
これは MI-MD インタフェース(set_params) が録再同時に設定を変更するため。
</p>

<p class=a2 style="margin-left:20%">
stride 情報はないが、ここは内部フォーマットであり、
precision != stride となるフォーマットはサポートしないので問題はない。
</p>
<p class=a2 style="margin-left:20%">
トラックミキサの性質上、encoding は常に <tt>AUDIO_ENCODING_SLINEAR_NE</tt>、
precision は <tt>AUDIO_INTERNAL_BITS</tt>(コンパイル時定数)である。


<p style="margin-left:8%; margin-top: 1em"><span class=a2>
次の sysctl を用意している。
</span></p>
<p style="margin-left:12%;"><span class=a2>
hw.audioN.blk_ms (int)
</p>
<p style="margin-left:20%;"><span class=a2>
デバイスの1ブロックの時間(msec)を取得・設定する。
デフォルトは 40msec だが、ハードウェア制約によって必要があれば変化する。
どうしたもんだか。
</span></p>


<p style="margin-top: 1em" valign="top"><b>MIXER
DEVICE</b></p>

<p class=comment style="margin-left:8%">ミキサーデバイスについてはほぼ未考察。
</p>

<p style="margin-left:8%;">The mixer device,
<i>/dev/mixer</i>, may be manipulated with ioctl(2) but does
not support read(2) or write(2). It supports the following
ioctl(2) commands:</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_GETDEV
(audio_device_t)</p>

<p style="margin-left:20%;">This command is the same as
described above for the sampling devices.</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_READ
(mixer_ctrl_t)</p>

<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_WRITE
(mixer_ctrl_t)</p>

<p style="margin-left:20%;">These commands read the current
mixer state or set new mixer state for the specified device
<i>dev</i>. <i>type</i> identifies which type of value is
supplied in the <i>mixer_ctrl_t</i> argument.</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">
#define AUDIO_MIXER_CLASS 0
#define AUDIO_MIXER_ENUM 1
#define AUDIO_MIXER_SET 2
#define AUDIO_MIXER_VALUE 3
typedef struct mixer_ctrl {
	int dev;			/* input: nth device */

	int type;
	union {
		int ord;		/* enum */
		int mask;		/* set */
		mixer_level_t value;	/* value */</p></td>
	} un;
} mixer_ctrl_t;

#define AUDIO_MIN_GAIN 0
#define AUDIO_MAX_GAIN 255
typedef struct mixer_level {
	int num_channels;
	u_char level[8];		/* [num_channels] */
} mixer_level_t;
#define AUDIO_MIXER_LEVEL_MONO 0
#define AUDIO_MIXER_LEVEL_LEFT 0
#define AUDIO_MIXER_LEVEL_RIGHT 1
</pre>
</p>

<p style="margin-left:20%; margin-top: 1em">For a mixer
value, the <i>value</i> field specifies both the number of
channels and the values for each channel. If the channel
count does not match the current channel count, the attempt
to change the setting may fail (depending on the hardware
device driver implementation). For an enumeration value, the
<i>ord</i> field should be set to one of the possible values
as returned by a prior AUDIO_MIXER_DEVINFO command. The type
AUDIO_MIXER_CLASS is only used for classifying particular
mixer device types and is not used for AUDIO_MIXER_READ or
AUDIO_MIXER_WRITE.</p>


<p style="margin-left:12%;margin-top: 1em">AUDIO_MIXER_DEVINFO
(mixer_devinfo_t)</p>

<p style="margin-left:20%;">This command is used
iteratively to fetch audio mixer device information into the
input/output mixer_devinfo_t argument. To query all the
supported devices, start with an index field of 0 and
continue with successive devices (1, 2, ...) until the
command returns an error.</p>

<p style="margin-left:20%; margin-top: 1em">
<pre style="margin-left:20%">
typedef struct mixer_devinfo {
	int index;		/* input: nth mixer device */

	audio_mixer_name_t label;
	int type;
	int mixer_class;
	int next, prev;
#define AUDIO_MIXER_LAST -1

	union {
		struct audio_mixer_enum {
			int num_mem;
			struct {
				audio_mixer_name_t label;
				int ord;
			} member[32];
		} e;
		struct audio_mixer_set {
			int num_mem;
			struct {
				audio_mixer_name_t label;
				int mask;
			} member[32];
		} s;
		struct audio_mixer_value {
			audio_mixer_name_t units;
			int num_channels;
			int delta;
		} v;
	} un;
} mixer_devinfo_t;</pre>
</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>label</i> field identifies the name of this particular
mixer control. The <i>index</i> field may be used as the
<i>dev</i> field in AUDIO_MIXER_READ and AUDIO_MIXER_WRITE
commands. The <i>type</i> field identifies the type of this
mixer control. Enumeration types are typically used for
on/off style controls (e.g. a mute control) or for
input/output device selection (e.g. select recording input
source from CD, line in, or microphone). Set types are
similar to enumeration types but any combination of the mask
bits can be used.</p>

<p style="margin-left:20%; margin-top: 1em">The
<i>mixer_class</i> field identifies what class of control
this is. The (arbitrary) value set by the hardware driver
may be determined by examining the <i>mixer_class</i> field
of the class itself, a mixer of type AUDIO_MIXER_CLASS. For
example, a mixer controlling the input gain on the line in
circuit would have a <i>mixer_class</i> that matches an
input class device with the name
&lsquo;&lsquo;inputs&rsquo;&rsquo; (AudioCinputs), and would
have a <i>label</i> of &lsquo;&lsquo;line&rsquo;&rsquo;
(AudioNline). Mixer controls which control audio circuitry
for a particular audio source (e.g. line-in, CD in, DAC
output) are collected under the input class, while those
which control all audio sources (e.g. master volume,
equalization controls) are under the output class. Hardware
devices capable of recording typically also have a record
class, for controls that only affect recording, and also a
monitor class.</p>

<p style="margin-left:20%; margin-top: 1em">The <i>next</i>
and <i>prev</i> may be used by the hardware device driver to
provide hints for the next and previous devices in a related
set (for example, the line in level control would have the
line in mute as its &lsquo;&lsquo;next&rsquo;&rsquo; value).
If there is no relevant next or previous value,
AUDIO_MIXER_LAST is specified.</p>

<p style="margin-left:20%; margin-top: 1em">For
AUDIO_MIXER_ENUM mixer control types, the enumeration values
and their corresponding names are filled in. For example, a
mute control would return appropriate values paired with
AudioNon and AudioNoff. For AUDIO_MIXER_VALUE and
AUDIO_MIXER_SET mixer control types, the channel count is
returned; the units name specifies what the level controls
(typical values are AudioNvolume, AudioNtreble,
AudioNbass).</p>

<p style="margin-left:8%; margin-top: 1em">By convention,
all the mixer devices can be distinguished from other mixer
controls because they use a name from one of the AudioC*
string values.</p>

<p style="margin-top: 1em" valign="top"><b>FILES</b> <br>
<p style="margin-left:8%">
/dev/audio <br>
<p style="margin-left:8%">
/dev/audioctl <br>
<p style="margin-left:8%">
/dev/sound <br>
<p style="margin-left:8%">
/dev/mixer <br>

<p style="margin-top: 1em" valign="top"><b>SEE ALSO</b> <br>

<p style="margin-left:8%;">audioctl(1), mixerctl(1),
ioctl(2), ossaudio(3), midi(4), radio(4)<span class=n8>, sysctl(8)</span></p>

<p style="margin-left:8%; margin-top: 1em"><b>ISA bus</b>
<br>
aria(4), ess(4), gus(4), guspnp(4), pas(4), sb(4), wss(4),
ym(4)</p>

<p style="margin-left:8%; margin-top: 1em"><b>PCI bus</b>
<br>
auacer(4), auich(4), auixp(4), autri(4), auvia(4),
azalia(4), clcs(4), clct(4), cmpci(4), eap(4), emuxki(4),
esa(4), esm(4), eso(4), fms(4), neo(4), sv(4), yds(4)</p>


<p style="margin-left:8%; margin-top: 1em"><b>TURBOchannel</b>
<br>
bba(4)</p>

<p style="margin-left:8%; margin-top: 1em"><b>USB</b> <br>
uaudio(4)</p>

<p style="margin-top: 1em" valign="top"><span class=n7><b>BUGS</b></span></p>

<p class=n7 style="margin-left:8%;">If the device is used in mmap(2)
it is currently always mapped for writing (playing) due to
VM system weirdness.</p>
<p class=bad style="margin-left:8%">
この問題は解決してないので削除しちゃだめ。
</p>

<p style="margin-top: 1em" valign="top"><span class=n8><b>HISTORY</b></span></p>
<p class=n8 style="margin-left:8%;">Support for virtual channels and
mixing first appeared in NetBSD&nbsp;8.0.</p>

<p style="margin-left:8%; margin-top: 1em">NetBSD&nbsp;7.1.1
September&nbsp;5, 2011 NetBSD&nbsp;7.1.1</p>
<hr>
</body>
</html>
