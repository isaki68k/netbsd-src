(チャンネルとレーンという用語を使用する)

Userland

[audioplay]
 input format: s8, u8, s16(le,be), s24(le,be), s32(le,be), mulaw
 カーネルが受け入れ可能なフォーマットに変換しながら出力

MI
 accept:
  [u|s]LINEAR([1..32],[8|16|24|32])[LE|BE]
  mulaw
  チャンネル数: 1..32
  周波数: 1k.. ぐらい。


[入力変換器]
入力エンコーディング変換 -> any to MIX enc (s16 or s32、コンパイル時確定)
  && エンディアン変換  -> HE

周波数変換 -> any to MIX freq
 (LPF とか)
 && チャンネルミキシング・デミキシング -> to MIX Channels
 モノラル入力をステレオデバイスに出すなら分配しないといけないし
 ステレオ入力をモノラルデバイスに出すなら合成しないといけない
 チャンネルバランス
 && レーンボリューム

[レーンミキサ]
 input: s16HE or s32HE (コンパイル時確定)
 レーンミキサの動作チャンネル数は MD Channels に等しい

レーンミキシング

//出力チャンネルバランス
//出力マスタボリューム      (vsドライバ用にとっておく?)

[出力変換器]
（周波数変換）
出力エンコーディング変換 : s16 or s32 -> MD sXX にする
 && エンディアン変換 HE -> MD ENDIAN


MD
 select: チャンネルが多くて 周波数がよくて ビット数が(32,16)の高い方で SLINEAR で できればHE
  周波数の良さ: 48kの倍数, 44.1kの倍数, 設定可能な最も高い周波数 の順
   (ユーザが指定できても良いかもしれないが・・・)

 s16XX -> mulaw とかは、もし MD が mulaw デバイスなら MD で実装(するか MI の関数を呼び出す)
 (24,32)デバイスとかも MD が変換する。

 最大チャンネル数: 18

------
録音


MD
 select: チャンネルが多くて 周波数が高くて ビット数が(32,16)の高い方で SLINEAR で できればHE

MI
[入力変換器]
 MD to s(16 or 32)HE

[デミキサ]
チャンネルバランス
レーンデミキシング
レーンボリューム
チャンネルミキシング・デミキシング -> to Requested Channels

[出力変換器]
周波数変換
エンコーディング変換
エンディアン変換

Userland
 format: u8, s16le, ...






バッファブロックサイズを 40ms にするのはどうか。
8kHz : 320フレーム
15625Hz: 625フレーム
44.1kHz: 1764フレーム
48kHz: 1920フレーム

50ms だと X68k で整数比にならないという極めてアレな理由。


write される

{
最長 40ms ぶん取り出す
変換する
ミキサに渡す
合成する
ミキサ出力に通知する
}

[ミキサ出力]
取り出す状況でなければ戻る
ミキサから40msぶん取り出す
変換する
ハードウェアに転送する

[ハードウェア]
転送が完了したら次を転送してくれとミキサ出力に通知する


 
---
ボリューム
 ユーザランド入力:
  uint8_t vol
   0..126   : vol / 256
   127..255 : (vol+1)/256
  (127 は要はボリューム半分にしたいんだろ？って事)
 内部形式
  uint16_t

ユーザランド入力
 フレーム未満の時、入力待ちが発生する
  フレーム未満のデータは次段に送出できないので待つ。
  クローズ、フラッシュ、ドレイン、フォーマット設定がコールされると、不完全フレームは破棄する。

  レーンはエンコーディング変換時に短いブロックに無音を付け足して完全化する。
   (ここで無音を付け足すことはできない。
    なぜなら、エンコーディングを全部知っていなければならないから。
    実装は可能だが、無駄である。)
 変換バッファ空き待ちが発生する(巨大な一発write時など)
 基本的に、ブロックフレームに分割して次段へ送出する。

    短い音をすぐに出したい時
    データを小さい単位で転送してきた時
    データの長さが半端な時
     -> 基本、クローズかドレインを義務付ける
 
エンコーディング変換
 ブロックフレームサイズ以下のときは無音を付け足す(SLINEAR なので0フィルでいい)
チャンネル変換
周波数変換
 ミキサバッファ空き待ちが発生する
レーンミキシング
 出力バッファ空き待ちが発生する
ハードウェア出力
 当然出力待ちが発生する
 ハードウェアが内部フォーマットをサポートしないとき、その変換は MD ドライバの責任。

録音
ハードウェア入力
 入力待ちが発生する。
 入力はブロックフレーム個のフレームが来るまで完了しない。
 次段へは必ずブロックフレーム単位で送出する。
 内部フォーマットで送出。ハードウェアが内部フォーマットをサポートしないとき、その変換は MD ドライバの責任。

レーンデミキシング
 前段からの入力待ちが発生する
 各レーンにコピー
周波数変換
 ユーザランドから要求された周波数へ変換
チャンネル変換
 ユーザランドから要求されたチャンネル数へ変換
エンコーディング変換
 ユーザランドから要求されたエンコーディングへ変換
ユーザランド出力
 前段からの入力待ちが発生する
 転送バイト数はフレーム単位で。(read で要求したサイズが読めるとは限らない)

むずかしいな。
録音時は Userland read 間のデータをどうするかが難しい。

time->
            |------|------|------|------|

read call   ^
read data   <---------->
read call                ^                ハードウェアの動作タイミングと次のread呼び出しは同期しないので、隙間にフレームができる
read data               <---------->      バッファリングされてて連結される。じゃあどこまでバッファリングするのか?
OR
read data                <---------->     実時間優先(これは今回の実装だと難しい)
OR
read data                 <---------->    次のブロックから(音が飛ぶ)。一発で大容量readを発行するしかない


            |------|------|------|------|

read call   ^
read data   <---------->
read call                ^                ハードウェアの動作タイミングと次のread呼び出しは同期しないので、隙間にフレームができる
read data               <---------->      これぐらいならわかるけど

            |------|------|------|------|

read call   ^
read data   <---------->
read call                           ^     こんなに遅延されたら
read data               <---------->      ありなん?


そもそも(1回に何バイト読みたいかはわかっても)トータル何フレーム読み込みたいか
がわからないのがイタイ。ここだけ RTOS でないといけないのに。

逆転の発想
read で録音を開始するのではなく、
open, set_format で録音を開始 動作中はずっとハードウェアは録音しておく
            |------|------|------|------|

open        ^
read call             ^
read data   <---------->

open で録音を開始して 1 ブロックは常時circlerバッファリング。
read がよばれたらバッファリング分と、不足分は次が来るのを待って返す。

タイミングカウンタ持つほうがいいかもしれん
read があったら切り上げ+1ブロックは読んでおくとかでもいいかもしれん
 バッファフラッシュが難しい



PLAY ONLY デバイス (ないけど)
 -> WRONLY でのみ開ける
    RDONLY,RDWR == EACCES
REC ONLY デバイス (ないけど)
 -> RDONLY でのみ開ける
    WRONLY,RDWR == EACCES
HALF デバイスはどうするの
 -> Open 時点で片側交互通行。
 RDONLY(REC) で一人開いたら以降 REC のみ(全員closeで初期化)
  REC状態で WRONLY == EPERM
 WRONLY(PLAY)で一人開いたら以降 PLAYのみ(全員closeで初期化)
  PLAY状態で RDONLY == EPERM
 RDWR == EACCES
  -> こうしないと低レイテンシと両立できない。後何フレームr/wするよ、って
     宣言があってその通りにアクセスするっていうんなら出来るけど、
     将来を完全に決定できるとは限らないから、この方法は非現実的。
FULL デバイス
 RDONLY, WRONLY, RDWR 自由。

EROFS が近いけど EWOFS がないから EPERM しかないかな

あるいは
　このへんの処理を全部MIX-MD間にあるpxhwが全部隠蔽してFULLに見せる
PLAY ONLY は RD は無音を返す
REC ONLY は WR はなにもしない
HALF は 1 ブロックごとに RD/WR を切り換えできるようになっていて
 そのときのリクエストキューに応じて動作する
  (録音再生はプチプチ切れるかもしれんし、無音を返すかもしれんし、
なにもしないかもしれん) こんな不安定でもいいんか？

再生専用のUserlandなら WRONLY で開けばいいし
録音専用のUserlandなら RDONLY で開けばいいし
両方リアルタイムにやるUserland なら RDWR で開けばいい
開けなければ即エラーでダメでしたで良いんじゃないか
 EACCES ならサポートしてませんよ
 EPERM なら他人が使ってて駄目です
　＊もっとふさわしいエラーコードがあるならそれ。とにかく
　　区別できることが重要

やってみたけど実世界の結果がどうなったかがユーザランドソフトはわからず
人間だけが「あれ音がでないな」では、ダメなんじゃないの
「スピーカーはつながってますか」「コンセントはつながってますか」
「ボリュームは大きくなってますか」なら分かるが
「HALFデバイスで他のレーンが録音してませんか」は分からんよ
んで録音再生の片側交互通行が確実に処理できるのはオープン時点なので
オープン時点でやるのが一番ユーザランドもやりやすいと思う。
オープンは出来たけど read/write 時点で EAGAIN なりで返されても
audio はリアルタイムデバイスなので役に立たない。

HALF は特に非互換変更だけど、もともと
「ハードディスクは特に管理しないからセクタ番号でアクセス」
みたいな状態から
「ファイルシステム経由しないアクセスは禁止よ」
になったようなものなので仕方ないのではないか。
排他オープンでミキサパススルー状態でも、DMA までユーザランドから
つつけるようにする気はない。フォーマットのみの透過で行きたい。


HALF device 1レーン目
open              setinfo              read              write
----------------------------------------------------------------------
O_WRONLY=OK
                  0=?*                 EBADF             ?*
                  PLAY=OK              EBADF             OK
                  REC=OK(?)*           EBADF             return 0*
                  PLAY|REC=PLAY*       EBADF             OK(たぶん)*

O_RDONLY=OK
                  0=*                  ?*                EBADF
                  PLAY=OK(?)*          無音*             EBADF
                  REC=OK               OK                EBADF
                  PLAY|REC=PLAY*       無音*             EBADF

O_RDWR=OK 
                  0=*                  ?*                ?*
                  PLAY=OK              無音*             OK
                  REC=OK               OK                return 0*
                  PLAY|REC=PLAY        無音*             OK



HALF device 2レーン目 (1レーン目: PLAY)
open              setinfo              read              write
----------------------------------------------------------------------
O_WRONLY=OK
                  0=?                  EBADF             ?
                  PLAY=OK              EBADF             OK
                  REC=OK(?)            EBADF             return 0
                  PLAY|REC=PLAY        EBADF             OK(たぶん)

O_RDONLY=OK
                  0                    ?                 EBADF
                  PLAY=OK(?)           無音              EBADF
                  REC=OK               ???               EBADF
                  PLAY|REC=PLAY        無音              EBADF

O_RDWR=OK
                  0                    ?                 ?
                  PLAY=OK              無音              OK
                  REC=OK(?)            ???               ?????????
                  PLAY|REC=PLAY        無音              OK


HALF device 2レーン目 (1レーン目: REC)
open              setinfo              read              write
----------------------------------------------------------------------
O_WRONLY=OK
                  0=?                  EBADF             ?
                  PLAY=OK              EBADF             OK
                  REC=OK(?)            EBADF             return 0
                  PLAY|REC=PLAY        EBADF             OK(たぶん)

O_RDONLY=OK
                  0                    ?                 EBADF
                  PLAY=OK(?)           無音              EBADF
                  REC=OK               OK                EBADF
                  PLAY|REC=PLAY        無音              EBADF

O_RDWR=OK
                  0                    ?                 ?
                  PLAY=OK              無音              OK
                  REC=OK               OK                return 0
                  PLAY|REC=PLAY        無音              OK






dev/sound
 開いたら前回の状態が保持されている
 setformat とかすると覚えておく
 最後に setformat されたものが次回見える
 setformat を呼び出した時、すでに開かれているレーンの状態は変更されない




mmap

現状のmmap仕様はフリーランしているデバイスバッファそのままが見えている、
なのだがこれって使いようがあるんだろうか？

カーネル内バッファメモリをmmapできてコミットする、ALSA/OSS のような
mmap 方式が求められているのではないか？



再生バッファフロー

        write(buf,n)                                                          mmap,ioctl(commit)
             |                                                                      |
             | ....userland.....                                                    |
             | ....kernel MI....                                                    |
             |                       +----------------------------------------------+
             |       === lane ===    |                                              |
             |                       V                                              |
+--------------------------------------+     EXCL                                   |
+ userio bufをポイント                 +-----------------------------+              |
+--------------------------------------+                             |              |
  |                                  |                               |              |
  +---------*==[encode convert]     +--------+                       |              |
  |         |                       +subframe+                       |              |
  |         V                       +--------+                       |              |
  |       +---------+                                                |              |
  |<------+convert  +                                                |              |
  |       +---------+                                                |              |
  |                                                                  |              |
  | if need ch-mix or freq                                           |              |
  +---------*==[ch-mix,ch-vol,mono-stereo]                           |              |
  |         |                                                        |              |
  |         V                                                        |              |
  |       +----------------+                                         |              |
  |       +chmix           +                                         |              |
  |       +----------------+                                         |              |
  |         |                                                        |              |
  |<--------*==[freq convert]                                        |              |
  |                                                                  |              |
  |                                                                  |              |
  |                                                                  |              |
  *==[lane volume]                                        +--------- | -------------+
  |                                                       |          |              |
  V                                                       V          |              |
+-------------------------------------------------------------+      |              |
+ lane  SLinternalHE                                          +      |              |
+-------------------------------------------------------------+      |              |
              |                                                      |              |
              |       === lane mixer ===                             |              |
        [lane mixing]                                                |              |
              |                                                      |              |
              V                                                      |              |
+---------------------------+                                        |              |
+ mix  SLinternal2HE        +                                        |              |
+---------------------------+                                        |              |
              |                                                      |              |
        [convert encoding]  64->16とか HE->(LE,BE)                   |              |
              |                                                      |              |
              V                                                      |              |
+---------------------------+                                        |              |
+ hw                        + <--------------------------------------+<-------------+
+---------------------------+
      |           |
      |           |  === MD driver ===
      |           |
      |           V
      |     +---------------------------+
      |     + MD convert buf            +
      |     +---------------------------+
      |           |
      V           V
+--------------------+
+ hardware port/mem  +
+--------------------+


ボリュームの話

N7 まで

/dev/audio play.gain, play.balance は両方ハードウェアに直結(output.masterをいじる)
/dev/mixer output.master はハードウェアに直結

N8

/dev/audio play.gain はソフトウェアゲイン, play.balance はハードウェアに直結
/dev/mixer output.master はハードウェアに直結

新実装(?)

(1) N7 互換
/dev/audio play.gain, play.balance は両方ハードウェアに直結(output.masterをいじる)
/dev/mixer output.master はハードウェアに直結

(2) N8 互換
/dev/audio play.gain はソフトウェアゲイン, play.balance はハードウェアに直結
/dev/mixer output.master はハードウェアに直結

(3) /dev/audio はソフトウェア扱い、/dev/mixer はハードウェア扱い
/dev/audio play.gain はソフトウェアゲイン, play.balance はソフトウェアバランス
/dev/mixer output.master はハードウェアに直結

本来は /dev/audio はユーザランドからは独立したレーンに見えている。
なのでレーン毎のソフトボリュームとソフトバランスがあるべきなんではないか。





dev_t dev 		外から来るハンドル 中は見えない

audio_softc sc		/dev/audio, /dev/sound, /dev/mixer /dev/audioctl のデバイス構造体
呼び出しがどのデバイスファイルなのかは dev 引数で分かる。

MD device: hw_if	sc->hw_if を介してハードウェアとやり取りする




チャンネルマッピング

・デファクトがあればMI側はそれに準拠する。

MI から MD に渡されるチャンネルの順序は Windows (uaudio) 互換の順序で送られる。

lane が受け取るチャンネル数は、userland が setinfo したチャンネル数。
lane が受け取るチャンネル順序が、Windows 互換の順序。
setinfo に今は無い channel_mask の設定はどうするの?  =>なにがし作る
 setinfo でのチャンネル数でデフォルトの channel_mask 値を内部セットする
  1 => CENTER
  2 => LEFT | RIGHT
  3 => LEFT | RIGHT | LOWFREQ
  4 => L|R| BACKL| BACKR ?
  5 => L|R| BACKL | BACKR | LOWFREQ ?
  6 => LEFT | RIGHT | CETNER | LOWFREQ | BACKL | BACKR


(lane がチャンネル合成する)
チャンネルリルーティングどうする
上と下のチャンネルマスクがわかっているので、リルーティングは技術的には可能ということ


lanemixer が処理するチャンネル数は、MD チャンネル数。
lanemixer が MD へ出力するチャンネル順序が Windows 互換の順序。
channel_mask レポートが Windows 互換になるようにする


